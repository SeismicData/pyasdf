


<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pyasdf.asdf_data_set &mdash; pyasdf 0.8.2 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=5349f25f" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />

  
    <link rel="stylesheet" href="../../_static/my-styles.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
      <script src="../../_static/documentation_options.js?v=dbee5847"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            pyasdf
              <img src="../../_static/pyasdf_logo.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../detailed_explanations.html">Detailed Explanations</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">pyasdf</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">pyasdf.asdf_data_set</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pyasdf.asdf_data_set</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Python implementation of the Adaptable Seismic Data Format (ASDF).</span>

<span class="sd">:copyright:</span>
<span class="sd">    Lion Krischer (lion.krischer@gmail.com), 2013-2021</span>
<span class="sd">:license:</span>
<span class="sd">    BSD 3-Clause (&quot;BSD New&quot; or &quot;BSD Simplified&quot;)</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Import ObsPy first as import h5py on some machines will some reset paths</span>
<span class="c1"># and lxml cannot be loaded anymore afterwards...</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">obspy</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">collections</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">io</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">multiprocessing</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">traceback</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">uuid</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">dill</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">h5py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">lxml.etree</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">packaging.version</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">prov</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">prov.model</span>


<span class="kn">from</span><span class="w"> </span><span class="nn">.exceptions</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">ASDFException</span><span class="p">,</span>
    <span class="n">ASDFWarning</span><span class="p">,</span>
    <span class="n">ASDFValueError</span><span class="p">,</span>
    <span class="n">NoStationXMLForStation</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.header</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">COMPRESSIONS</span><span class="p">,</span>
    <span class="n">FORMAT_NAME</span><span class="p">,</span>
    <span class="n">SUPPORTED_FORMAT_VERSIONS</span><span class="p">,</span>
    <span class="n">MSG_TAGS</span><span class="p">,</span>
    <span class="n">MAX_MEMORY_PER_WORKER_IN_MB</span><span class="p">,</span>
    <span class="n">POISON_PILL</span><span class="p">,</span>
    <span class="n">PROV_FILENAME_REGEX</span><span class="p">,</span>
    <span class="n">TAG_REGEX</span><span class="p">,</span>
    <span class="n">VALID_SEISMOGRAM_DTYPES</span><span class="p">,</span>
    <span class="n">AUXILIARY_DATA_PATH_PART_PATTERN</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.query</span><span class="w"> </span><span class="kn">import</span> <span class="n">Query</span><span class="p">,</span> <span class="n">merge_query_functions</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.utils</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">is_mpi_env</span><span class="p">,</span>
    <span class="n">StationAccessor</span><span class="p">,</span>
    <span class="n">sizeof_fmt</span><span class="p">,</span>
    <span class="n">ReceivedMessage</span><span class="p">,</span>
    <span class="n">pretty_receiver_log</span><span class="p">,</span>
    <span class="n">pretty_sender_log</span><span class="p">,</span>
    <span class="n">JobQueueHelper</span><span class="p">,</span>
    <span class="n">StreamBuffer</span><span class="p">,</span>
    <span class="n">AuxiliaryDataGroupAccessor</span><span class="p">,</span>
    <span class="n">AuxiliaryDataContainer</span><span class="p">,</span>
    <span class="n">ProvenanceAccessor</span><span class="p">,</span>
    <span class="n">split_qualified_name</span><span class="p">,</span>
    <span class="n">_read_string_array</span><span class="p">,</span>
    <span class="n">FilteredWaveformAccessor</span><span class="p">,</span>
    <span class="n">label2string</span><span class="p">,</span>
    <span class="n">labelstring2list</span><span class="p">,</span>
    <span class="n">AuxiliaryDataAccessor</span><span class="p">,</span>
    <span class="n">wf_name2tag</span><span class="p">,</span>
    <span class="n">to_list_of_resource_identifiers</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.inventory_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">isolate_and_merge_station</span><span class="p">,</span> <span class="n">merge_inventories</span>


<span class="c1"># Always raise ASDF warnings as they are important for the user.</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;always&quot;</span><span class="p">,</span> <span class="n">ASDFWarning</span><span class="p">)</span>


<div class="viewcode-block" id="ASDFDataSet">
<a class="viewcode-back" href="../../asdf_data_set.html#pyasdf.asdf_data_set.ASDFDataSet">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ASDFDataSet</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Object dealing with Adaptable Seismic Data Format (ASDF).</span>

<span class="sd">    Central object of this Python package.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">q</span> <span class="o">=</span> <span class="n">Query</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">,</span>
        <span class="n">compression</span><span class="o">=</span><span class="s2">&quot;gzip-3&quot;</span><span class="p">,</span>
        <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">mpi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">,</span>
        <span class="n">single_item_read_limit_in_mb</span><span class="o">=</span><span class="mf">4096.0</span><span class="p">,</span>
        <span class="n">format_version</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :type filename: str</span>
<span class="sd">        :param filename: The filename of the HDF5 file (to be).</span>
<span class="sd">        :type compression: str</span>
<span class="sd">        :param compression: The compression to use. Defaults to</span>
<span class="sd">            ``&quot;gzip-3&quot;`` which yielded good results in the past. Will</span>
<span class="sd">            only be applied to newly created data sets. Existing ones are not</span>
<span class="sd">            touched. Using parallel I/O will also disable compression as it</span>
<span class="sd">            is not possible to use both at the same time.</span>

<span class="sd">            **Available compressions choices (all of them are lossless):**</span>

<span class="sd">            * ``None``: No compression</span>
<span class="sd">            * ``&quot;gzip-0&quot;`` - ``&quot;gzip-9&quot;``: Gzip compression level 0  (worst</span>
<span class="sd">              but fast) to 9 (best but slow)</span>
<span class="sd">            * ``&quot;lzf&quot;``: LZF compression</span>
<span class="sd">            * ``&quot;szip-ec-8&quot;``: szip compression</span>
<span class="sd">            * ``&quot;szip-ec-10&quot;``: szip compression</span>
<span class="sd">            * ``&quot;szip-nn-8&quot;``: szip compression</span>
<span class="sd">            * ``&quot;szip-nn-10&quot;``: szip compression</span>

<span class="sd">        :type shuffle: bool</span>
<span class="sd">        :param shuffle: Turn the shuffle filter on or off. Turning it on</span>
<span class="sd">            oftentimes increases the compression ratio at the expense of</span>
<span class="sd">            some speed.</span>
<span class="sd">        :type debug: bool</span>
<span class="sd">        :param debug: If True, print debug messages. Potentially very verbose.</span>
<span class="sd">        :param mpi: Force MPI on/off. Don&#39;t touch this unless you have a</span>
<span class="sd">            reason.</span>
<span class="sd">        :type mpi: bool</span>
<span class="sd">        :param mode: The mode the file is opened in. Passed to the</span>
<span class="sd">            underlying :class:`h5py.File` constructor. pyasdf expects to be</span>
<span class="sd">            able to write to files for many operations so it might result in</span>
<span class="sd">            strange errors if a read-only mode is used. Nonetheless this is</span>
<span class="sd">            quite useful for some use cases as long as one is aware of the</span>
<span class="sd">            potential repercussions.</span>
<span class="sd">        :type mode: str</span>
<span class="sd">        :type single_item_read_limit_in_mb: float</span>
<span class="sd">        :param single_item_read_limit_in_mb: This limits the amount of waveform</span>
<span class="sd">            data that can be read with a simple attribute or dictionary</span>
<span class="sd">            access. Some ASDF files can get very big and this raises an</span>
<span class="sd">            error if one tries to access more then the specified value. This</span>
<span class="sd">            is mainly to guard against accidentally filling ones memory on</span>
<span class="sd">            the interactive command line when just exploring an ASDF data</span>
<span class="sd">            set. There are other ways to still access data and even this</span>
<span class="sd">            setting can be overwritten. This test will only be triggered when</span>
<span class="sd">            the file is beigger thatn this limit in the first place as the test</span>
<span class="sd">            is fairly expensive.</span>
<span class="sd">        :type format_version: str</span>
<span class="sd">        :type format_version: The version of ASDF to use. If not given,</span>
<span class="sd">            it will use the most recent version (currently 1.0.1) if the</span>
<span class="sd">            ASDF file does not yes exist, or the version specified in the file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">format_version</span> <span class="ow">and</span> <span class="n">format_version</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">SUPPORTED_FORMAT_VERSIONS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ASDFValueError</span><span class="p">(</span>
                <span class="s2">&quot;ASDF version &#39;</span><span class="si">%s</span><span class="s2">&#39; is not supported. Supported versions: </span><span class="si">%s</span><span class="s2">&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">format_version</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">SUPPORTED_FORMAT_VERSIONS</span><span class="p">))</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__force_mpi</span> <span class="o">=</span> <span class="n">mpi</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="n">debug</span>

        <span class="c1"># The limit on how much data can be read with a single item access.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">single_item_read_limit_in_mb</span> <span class="o">=</span> <span class="n">single_item_read_limit_in_mb</span>

        <span class="c1"># Deal with compression settings.</span>
        <span class="k">if</span> <span class="n">compression</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">COMPRESSIONS</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Unknown compressions &#39;</span><span class="si">%s</span><span class="s2">&#39;. Available compressions: </span><span class="se">\n\t</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">compression</span><span class="p">,</span>
                <span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">COMPRESSIONS</span><span class="o">.</span><span class="n">keys</span><span class="p">()])),</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__compression</span> <span class="o">=</span> <span class="n">COMPRESSIONS</span><span class="p">[</span><span class="n">compression</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__shuffle</span> <span class="o">=</span> <span class="n">shuffle</span>
        <span class="c1"># Turn off compression for parallel I/O. Any already written</span>
        <span class="c1"># compressed data will be fine. Don&#39;t need to raise it if file is</span>
        <span class="c1"># opened in read-only mode.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__compression</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span> <span class="ow">and</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s2">&quot;r&quot;</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;Compression will be disabled as parallel HDF5 does not &quot;</span>
                <span class="s2">&quot;support compression&quot;</span>
            <span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">ASDFWarning</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__compression</span> <span class="o">=</span> <span class="n">COMPRESSIONS</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__shuffle</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># No need to shuffle if no compression is used.</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">__compression</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__shuffle</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Open file or take an already open HDF5 file object.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__file</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__file</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span>
                <span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">driver</span><span class="o">=</span><span class="s2">&quot;mpio&quot;</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">comm</span>
            <span class="p">)</span>

        <span class="c1"># Workaround to HDF5 only storing the relative path by default.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__original_filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

        <span class="c1"># Write the file format header to the file.</span>
        <span class="k">if</span> <span class="s2">&quot;file_format&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__file</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__file</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;file_format&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span> <span class="o">!=</span> <span class="n">FORMAT_NAME</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Not a &#39;</span><span class="si">%s</span><span class="s2">&#39; file.&quot;</span> <span class="o">%</span> <span class="n">FORMAT_NAME</span>
                <span class="k">raise</span> <span class="n">ASDFException</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="c1"># Raise a warning as this is a bit fishy.</span>
            <span class="k">if</span> <span class="s2">&quot;file_format_version&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__file</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;No file format version given in file &#39;</span><span class="si">%s</span><span class="s2">&#39;. The &quot;</span>
                    <span class="s2">&quot;program will continue but the result is undefined.&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span>
                <span class="p">)</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">ASDFWarning</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__file</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;file_format&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zeropad_ascii_string</span><span class="p">(</span><span class="n">FORMAT_NAME</span><span class="p">)</span>

        <span class="c1"># Deal with the file format version. `format_version` is either None</span>
        <span class="c1"># or valid (this is checked above).</span>
        <span class="n">__most_recent_version</span> <span class="o">=</span> <span class="s2">&quot;1.0.3&quot;</span>
        <span class="c1"># Case 1: Already some kind of format version in the file.</span>
        <span class="k">if</span> <span class="s2">&quot;file_format_version&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__file</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
            <span class="n">version_in_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__file</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;file_format_version&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">version_in_file</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">SUPPORTED_FORMAT_VERSIONS</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">asdf_format_version</span> <span class="o">=</span> <span class="n">format_version</span> <span class="ow">or</span> <span class="n">__most_recent_version</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;The file claims an ASDF version of </span><span class="si">%s</span><span class="s2">. This &quot;</span>
                    <span class="s2">&quot;version of pyasdf only supports versions: </span><span class="si">%s</span><span class="s2">. All &quot;</span>
                    <span class="s2">&quot;following write operations will use version </span><span class="si">%s</span><span class="s2"> - &quot;</span>
                    <span class="s2">&quot;other tools might not be able to read the files &quot;</span>
                    <span class="s2">&quot;again - proceed with caution.&quot;</span>
                    <span class="o">%</span> <span class="p">(</span>
                        <span class="n">version_in_file</span><span class="p">,</span>
                        <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">SUPPORTED_FORMAT_VERSIONS</span><span class="p">),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">asdf_format_version</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">ASDFWarning</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">format_version</span> <span class="ow">and</span> <span class="n">format_version</span> <span class="o">!=</span> <span class="n">version_in_file</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;You are forcing ASDF version </span><span class="si">%s</span><span class="s2"> but the version &quot;</span>
                        <span class="s2">&quot;of the file is </span><span class="si">%s</span><span class="s2">. Please proceed with caution &quot;</span>
                        <span class="s2">&quot;as other tools might not be able to read the &quot;</span>
                        <span class="s2">&quot;file again.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">format_version</span><span class="p">,</span> <span class="n">version_in_file</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">ASDFWarning</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">asdf_format_version</span> <span class="o">=</span> <span class="n">format_version</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">asdf_format_version</span> <span class="o">=</span> <span class="n">version_in_file</span>
        <span class="c1"># Case 2: Format version not in file yet.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If not given, use the most recent one.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">asdf_format_version</span> <span class="o">=</span> <span class="n">format_version</span> <span class="ow">or</span> <span class="n">__most_recent_version</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__file</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;file_format_version&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zeropad_ascii_string</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">asdf_format_version</span>
            <span class="p">)</span>

        <span class="c1"># Just a final safety check - should not be able to fail!</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">asdf_format_version</span> <span class="ow">in</span> <span class="n">SUPPORTED_FORMAT_VERSIONS</span>

        <span class="c1"># Useful for programmatic checks.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_loose_asdf_format_version</span> <span class="o">=</span> <span class="n">packaging</span><span class="o">.</span><span class="n">version</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">asdf_format_version</span>
        <span class="p">)</span>

        <span class="c1"># Create the waveform and provenance groups if mode is not &quot;r&quot;.</span>
        <span class="k">if</span> <span class="s2">&quot;Waveforms&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__file</span> <span class="ow">and</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s2">&quot;r&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__file</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s2">&quot;Waveforms&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;Provenance&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__file</span> <span class="ow">and</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s2">&quot;r&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__file</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s2">&quot;Provenance&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;AuxiliaryData&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__file</span> <span class="ow">and</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s2">&quot;r&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__file</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s2">&quot;AuxiliaryData&quot;</span><span class="p">)</span>

        <span class="c1"># Easy access to the waveforms.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">waveforms</span> <span class="o">=</span> <span class="n">StationAccessor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">auxiliary_data</span> <span class="o">=</span> <span class="n">AuxiliaryDataGroupAccessor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">provenance</span> <span class="o">=</span> <span class="n">ProvenanceAccessor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Force synchronous init if run in an MPI environment.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cleanup. Force flushing and close the file.</span>

<span class="sd">        If called with MPI this will also enable MPI to cleanly shutdown.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_close</span><span class="p">()</span>
        <span class="c1"># We never want the __del__ method to raise but at least a warning</span>
        <span class="c1"># should be printed.</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Failed to flush and close the file due to: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">ASDFWarning</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        More or less comprehensive equality check. Potentially quite slow as</span>
<span class="sd">        it checks all data.</span>

<span class="sd">        :type other:`~pyasdf.asdf_data_set.ASDFDDataSet`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_waveform_group</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">_waveform_group</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_provenance_group</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">_provenance_group</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">events</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">station</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_waveform_group</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">other_group</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_waveform_group</span><span class="p">[</span><span class="n">station</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">tag</span><span class="p">,</span> <span class="n">data_set</span> <span class="ow">in</span> <span class="n">group</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">other_data_set</span> <span class="o">=</span> <span class="n">other_group</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;StationXML&quot;</span><span class="p">:</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_array_equal</span><span class="p">(</span><span class="n">data_set</span><span class="p">[()],</span> <span class="n">other_data_set</span><span class="p">[()])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_allclose</span><span class="p">(</span><span class="n">data_set</span><span class="p">[()],</span> <span class="n">other_data_set</span><span class="p">[()])</span>
                <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enable usage as a context manager.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_val</span><span class="p">,</span> <span class="n">exc_tb</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enable usage as a context manager.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__del__</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__delattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="c1"># Only the events can be deleted.</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;events&quot;</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__file</span><span class="p">[</span><span class="s2">&quot;QuakeML&quot;</span><span class="p">]</span>
        <span class="c1"># Otherwise try to get the item and if that succeed, raise an error</span>
        <span class="c1"># that it cannot be deleted.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Triggers an AttributeError if the attribute does not exist.</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Attribute &#39;</span><span class="si">%s</span><span class="s2">&#39; cannot be deleted.&quot;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>

<div class="viewcode-block" id="ASDFDataSet.flush">
<a class="viewcode-back" href="../../asdf_data_set.html#pyasdf.asdf_data_set.ASDFDataSet.flush">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">flush</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Flush the underlying HDF5 file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># A boolean check return False if the file has already been closed</span>
        <span class="c1"># and thus cannot be flushed.</span>
        <span class="c1"># There is also a strange interaction with capturing stdout/stderr</span>
        <span class="c1"># where the __file attribute no longer exists. But it should</span>
        <span class="c1"># be pretty safe to assume that we then also don&#39;t have to flush.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_ASDFDataSet__file&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__file</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attempt to close the underlying HDF5 file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_zeropad_ascii_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a zero padded ASCII string in the most compatible way possible.</span>

<span class="sd">        Might later need to handle bytes/unicode.</span>

<span class="sd">        :param text: The text to be converted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">bytes_</span><span class="p">((</span><span class="n">text</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\x00</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_waveform_group</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__file</span><span class="p">[</span><span class="s2">&quot;Waveforms&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_provenance_group</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__file</span><span class="p">[</span><span class="s2">&quot;Provenance&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_auxiliary_data_group</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__file</span><span class="p">[</span><span class="s2">&quot;AuxiliaryData&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">asdf_format_version_in_file</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the version of the ASDF version specified in the file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__file</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;file_format_version&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">filename</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the path of the underlying file on the filesystem. Works in most</span>
<span class="sd">        circumstances.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__original_filename</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">mpi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a named tuple with ``comm``, ``rank``, ``size``, and ``MPI``</span>
<span class="sd">        if run with MPI and ``False`` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Simple cache as this is potentially accessed a lot.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;__is_mpi&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__is_mpi</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__force_mpi</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__is_mpi</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">__force_mpi</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__is_mpi</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__is_mpi</span> <span class="o">=</span> <span class="n">is_mpi_env</span><span class="p">()</span>

        <span class="c1"># If it actually is an mpi environment, set the communicator and the</span>
        <span class="c1"># rank.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__is_mpi</span><span class="p">:</span>
            <span class="c1"># Check if HDF5 has been complied with parallel I/O.</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">get_config</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s2">&quot;mpi&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">mpi</span><span class="p">:</span>
                <span class="n">is_parallel</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">is_parallel</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_parallel</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Running under MPI requires HDF5/h5py to be complied &quot;</span>
                    <span class="s2">&quot;with support for parallel I/O.&quot;</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="kn">import</span><span class="w"> </span><span class="nn">mpi4py</span>

            <span class="c1"># This is not needed on most mpi4py installations.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">mpi4py</span><span class="o">.</span><span class="n">MPI</span><span class="o">.</span><span class="n">Is_initialized</span><span class="p">():</span>
                <span class="n">mpi4py</span><span class="o">.</span><span class="n">MPI</span><span class="o">.</span><span class="n">Init</span><span class="p">()</span>

            <span class="c1"># Set mpi tuple to easy class wide access.</span>
            <span class="n">mpi_ns</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;mpi_ns&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;comm&quot;</span><span class="p">,</span> <span class="s2">&quot;rank&quot;</span><span class="p">,</span> <span class="s2">&quot;size&quot;</span><span class="p">,</span> <span class="s2">&quot;MPI&quot;</span><span class="p">])</span>
            <span class="n">comm</span> <span class="o">=</span> <span class="n">mpi4py</span><span class="o">.</span><span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__is_mpi</span> <span class="o">=</span> <span class="n">mpi_ns</span><span class="p">(</span>
                <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">MPI</span><span class="o">=</span><span class="n">mpi4py</span><span class="o">.</span><span class="n">MPI</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__is_mpi</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">events</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all events stored in the data set.</span>

<span class="sd">        :rtype: An ObsPy :class:`~obspy.core.event.Catalog` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;QuakeML&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__file</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">obspy</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">Catalog</span><span class="p">()</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__file</span><span class="p">[</span><span class="s2">&quot;QuakeML&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[()]):</span>
            <span class="k">return</span> <span class="n">obspy</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">Catalog</span><span class="p">()</span>

        <span class="k">with</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">_read_string_array</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="k">as</span> <span class="n">buf</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">cat</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">read_events</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;quakeml&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="c1"># ObsPy is not able to read empty QuakeML files but they are</span>
                <span class="c1"># still valid QuakeML files.</span>
                <span class="n">buf</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">quakeml</span><span class="o">.</span><span class="n">_validate</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="c1"># If validation is successful, but the initial read failed,</span>
                <span class="c1"># it must have been an empty QuakeML object.</span>
                <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">cat</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">Catalog</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Re-raise exception</span>
                    <span class="k">raise</span>
        <span class="k">return</span> <span class="n">cat</span>

    <span class="nd">@events</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">events</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the events of the dataset.</span>

<span class="sd">        :param event: One or more events. Will replace all existing ones.</span>
<span class="sd">        :type event: :class:`~obspy.core.event.Event` or</span>
<span class="sd">            :class:`~obspy.core.event.Catalog`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">obspy</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">Event</span><span class="p">):</span>
            <span class="n">cat</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">Catalog</span><span class="p">(</span><span class="n">events</span><span class="o">=</span><span class="p">[</span><span class="n">event</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">obspy</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">Catalog</span><span class="p">):</span>
            <span class="n">cat</span> <span class="o">=</span> <span class="n">event</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Must be an ObsPy event or catalog instance&quot;</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span> <span class="k">as</span> <span class="n">buf</span><span class="p">:</span>
            <span class="n">cat</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;quakeml&quot;</span><span class="p">)</span>
            <span class="n">buf</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">buf</span><span class="o">.</span><span class="n">read</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;byte&quot;</span><span class="p">))</span>

        <span class="c1"># Create the QuakeML data set if it does not exist.</span>
        <span class="k">if</span> <span class="s2">&quot;QuakeML&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__file</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__file</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
                <span class="s2">&quot;QuakeML&quot;</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;byte&quot;</span><span class="p">),</span>
                <span class="n">compression</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__compression</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">compression_opts</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__compression</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">shuffle</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__shuffle</span><span class="p">,</span>
                <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,),</span>
                <span class="n">maxshape</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,),</span>
                <span class="n">fletcher32</span><span class="o">=</span><span class="ow">not</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__file</span><span class="p">[</span><span class="s2">&quot;QuakeML&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__file</span><span class="p">[</span><span class="s2">&quot;QuakeML&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">data</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">waveform_tags</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a set with all tags in the dataset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span>
            <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">get_waveform_tags</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">waveforms</span><span class="p">)</span>
        <span class="p">)</span>

<div class="viewcode-block" id="ASDFDataSet.add_auxiliary_data_file">
<a class="viewcode-back" href="../../asdf_data_set.html#pyasdf.asdf_data_set.ASDFDataSet.add_auxiliary_data_file">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_auxiliary_data_file</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">filename_or_object</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">provenance_id</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Special function adding a file or file like object as an auxiliary</span>
<span class="sd">        data object denoting a file. This is very useful to store arbitrary</span>
<span class="sd">        files in ASDF.</span>

<span class="sd">        :param filename_or_object: Filename, open-file or file-like object.</span>
<span class="sd">            File should really be opened in binary mode, but this i not</span>
<span class="sd">            checked.</span>
<span class="sd">        :param path: The path of the file. Has the same limitations as normal</span>
<span class="sd">            tags.</span>
<span class="sd">        :param parameters: Any additional options, as a Python dictionary.</span>
<span class="sd">        :param provenance_id: The id of the provenance of this data. The</span>
<span class="sd">            provenance information itself must be added separately. Must be</span>
<span class="sd">            given as a qualified name, e.g. ``&#39;{namespace_uri}id&#39;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">filename_or_object</span><span class="p">,</span> <span class="s2">&quot;read&quot;</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">filename_or_object</span><span class="o">.</span><span class="n">read</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;byte&quot;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename_or_object</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">fh</span><span class="o">.</span><span class="n">read</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;byte&quot;</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">parameters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parameters</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_auxiliary_data</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">data_type</span><span class="o">=</span><span class="s2">&quot;Files&quot;</span><span class="p">,</span>
            <span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">,</span>
            <span class="n">parameters</span><span class="o">=</span><span class="n">parameters</span><span class="p">,</span>
            <span class="n">provenance_id</span><span class="o">=</span><span class="n">provenance_id</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="ASDFDataSet.add_auxiliary_data">
<a class="viewcode-back" href="../../asdf_data_set.html#pyasdf.asdf_data_set.ASDFDataSet.add_auxiliary_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_auxiliary_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">provenance_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds auxiliary data to the file.</span>

<span class="sd">        :param data: The actual data as a n-dimensional numpy array.</span>
<span class="sd">        :param data_type: The type of data, think of it like a subfolder.</span>
<span class="sd">        :param path: The path of the data. Must be unique per data_type. Can</span>
<span class="sd">            be a path separated by forward slashes at which point it will be</span>
<span class="sd">            stored in a nested structure.</span>
<span class="sd">        :param parameters: Any additional options, as a Python dictionary.</span>
<span class="sd">        :param provenance_id: The id of the provenance of this data. The</span>
<span class="sd">            provenance information itself must be added separately. Must be</span>
<span class="sd">            given as a qualified name, e.g. ``&#39;{namespace_uri}id&#39;``.</span>


<span class="sd">        The data type is the category of the data and the path the name of</span>
<span class="sd">        that particular piece of data within that category.</span>

<span class="sd">        &gt;&gt;&gt; ds.add_auxiliary_data(numpy.random.random(10),</span>
<span class="sd">        ...                       data_type=&quot;RandomArrays&quot;,</span>
<span class="sd">        ...                       path=&quot;test_data&quot;,</span>
<span class="sd">        ...                       parameters={&quot;a&quot;: 1, &quot;b&quot;: 2})</span>
<span class="sd">        &gt;&gt;&gt; ds.auxiliary_data.RandomArrays.test_data</span>
<span class="sd">        Auxiliary Data of Type &#39;RandomArrays&#39;</span>
<span class="sd">        Path: &#39;test_data&#39;</span>
<span class="sd">        Data shape: &#39;(10, )&#39;, dtype: &#39;float64&#39;</span>
<span class="sd">        Parameters:</span>
<span class="sd">            a: 1</span>
<span class="sd">            b: 2</span>

<span class="sd">        The path can contain forward slashes to create a nested hierarchy of</span>
<span class="sd">        auxiliary data.</span>

<span class="sd">        &gt;&gt;&gt; ds.add_auxiliary_data(numpy.random.random(10),</span>
<span class="sd">        ...                       data_type=&quot;RandomArrays&quot;,</span>
<span class="sd">        ...                       path=&quot;some/nested/path/test_data&quot;,</span>
<span class="sd">        ...                       parameters={&quot;a&quot;: 1, &quot;b&quot;: 2})</span>
<span class="sd">        &gt;&gt;&gt; ds.auxiliary_data.RandomArrays.some.nested.path.test_data</span>
<span class="sd">        Auxiliary Data of Type &#39;RandomArrays&#39;</span>
<span class="sd">        Path: &#39;some/nested/path/test_data&#39;</span>
<span class="sd">        Data shape: &#39;(10, )&#39;, dtype: &#39;float64&#39;</span>
<span class="sd">        Parameters:</span>
<span class="sd">            a: 1</span>
<span class="sd">            b: 2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Assert the data type name.</span>
        <span class="n">pattern</span> <span class="o">=</span> <span class="n">AUXILIARY_DATA_PATH_PART_PATTERN</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">asdf_format_version</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">data_type</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ASDFValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Data type name &#39;</span><span class="si">{</span><span class="n">data_type</span><span class="si">}</span><span class="s2">&#39; is invalid. It must validate &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;against the regular expression &#39;</span><span class="si">{</span><span class="n">pattern</span><span class="si">}</span><span class="s2">&#39; in ASDF version &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">asdf_format_version</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Split the path.</span>
        <span class="n">tag_path</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">tag_path</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ASDFValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Path part name &#39;</span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2">&#39; is invalid. It must validate &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;against the regular expression &#39;</span><span class="si">{</span><span class="n">pattern</span><span class="si">}</span><span class="s2">&#39; in ASDF &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;version &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">asdf_format_version</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">provenance_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Will raise an error if not a valid qualified name.</span>
            <span class="n">split_qualified_name</span><span class="p">(</span><span class="n">provenance_id</span><span class="p">)</span>
        <span class="c1"># Complicated multi-step process but it enables one to use</span>
        <span class="c1"># parallel I/O with the same functions.</span>
        <span class="n">info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_auxiliary_data_get_collective_information</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">data_type</span><span class="o">=</span><span class="n">data_type</span><span class="p">,</span>
            <span class="n">tag_path</span><span class="o">=</span><span class="n">tag_path</span><span class="p">,</span>
            <span class="n">parameters</span><span class="o">=</span><span class="n">parameters</span><span class="p">,</span>
            <span class="n">provenance_id</span><span class="o">=</span><span class="n">provenance_id</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_auxiliary_data_write_collective_information</span><span class="p">(</span><span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_auxiliary_data_write_independent_information</span><span class="p">(</span><span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_add_auxiliary_data_get_collective_information</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">tag_path</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">provenance_id</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The information required for the collective part of adding some</span>
<span class="sd">        auxiliary data.</span>

<span class="sd">        This will extract the group name, the parameters of the dataset to</span>
<span class="sd">        be created, and the attributes of the dataset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;provenance_id&quot;</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ASDFValueError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;provenance_id&#39; is a reserved parameter &quot;</span>
                <span class="s2">&quot;and cannot be used as an arbitrary &quot;</span>
                <span class="s2">&quot;parameters.&quot;</span>
            <span class="p">)</span>
        <span class="c1"># If the provenance id is set, add it to the parameters. At this</span>
        <span class="c1"># point it is assumed, that the id is valid.</span>
        <span class="k">if</span> <span class="n">provenance_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parameters</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
            <span class="n">parameters</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="p">{</span><span class="s2">&quot;provenance_id&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zeropad_ascii_string</span><span class="p">(</span><span class="n">provenance_id</span><span class="p">)}</span>
            <span class="p">)</span>

        <span class="n">group_name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">data_type</span><span class="p">,</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tag_path</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">group_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_auxiliary_data_group</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Data &#39;</span><span class="si">%s</span><span class="s2">&#39; already exists in file. Will not be added!&quot;</span> <span class="o">%</span> <span class="n">group_name</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">ASDFWarning</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># XXX: Figure out why this is necessary. It should work according to</span>
        <span class="c1"># the specs.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="p">:</span>
            <span class="n">fletcher32</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fletcher32</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">info</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;data_name&quot;</span><span class="p">:</span> <span class="n">group_name</span><span class="p">,</span>
            <span class="s2">&quot;data_type&quot;</span><span class="p">:</span> <span class="n">data_type</span><span class="p">,</span>
            <span class="s2">&quot;dataset_creation_params&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tag_path</span><span class="p">),</span>
                <span class="s2">&quot;shape&quot;</span><span class="p">:</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                <span class="s2">&quot;compression&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__compression</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="s2">&quot;compression_opts&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__compression</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="s2">&quot;shuffle&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__shuffle</span><span class="p">,</span>
                <span class="s2">&quot;fletcher32&quot;</span><span class="p">:</span> <span class="n">fletcher32</span><span class="p">,</span>
                <span class="s2">&quot;maxshape&quot;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">([</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)),</span>
            <span class="p">},</span>
            <span class="s2">&quot;dataset_attrs&quot;</span><span class="p">:</span> <span class="n">parameters</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">info</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_add_auxiliary_data_write_independent_information</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes the independent part of auxiliary data to the file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_auxiliary_data_group</span><span class="p">[</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;data_name&quot;</span><span class="p">]][:]</span> <span class="o">=</span> <span class="n">data</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_add_auxiliary_data_write_collective_information</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes the collective part of auxiliary data to the file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data_type</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s2">&quot;data_type&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">data_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_auxiliary_data_group</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_auxiliary_data_group</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">data_type</span><span class="p">)</span>
        <span class="n">group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_auxiliary_data_group</span><span class="p">[</span><span class="n">data_type</span><span class="p">]</span>

        <span class="c1"># workaround for a bug in hdf5 1.10 and PPC64</span>
        <span class="n">info</span><span class="p">[</span><span class="s2">&quot;dataset_creation_params&quot;</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">group</span>

        <span class="n">ds</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="o">**</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;dataset_creation_params&quot;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">info</span><span class="p">[</span><span class="s2">&quot;dataset_attrs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">ds</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

<div class="viewcode-block" id="ASDFDataSet.add_quakeml">
<a class="viewcode-back" href="../../asdf_data_set.html#pyasdf.asdf_data_set.ASDFDataSet.add_quakeml">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_quakeml</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a QuakeML file or an existing ObsPy event to the data set.</span>

<span class="sd">        An exception will be raised if an event is attempted to be added</span>
<span class="sd">        that already exists within the data set. Duplicates are detected</span>
<span class="sd">        based on the public ids of the events.</span>

<span class="sd">        :param event: Filename or existing ObsPy event object.</span>
<span class="sd">        :type event: :class:`~obspy.core.event.Event` or</span>
<span class="sd">            :class:`~obspy.core.event.Catalog`</span>
<span class="sd">        :raises: ValueError</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        For now we will create a new ASDF file but one can also use an</span>
<span class="sd">        existing one.</span>

<span class="sd">        &gt;&gt;&gt; impory pyasdf</span>
<span class="sd">        &gt;&gt;&gt; import obspy</span>
<span class="sd">        &gt;&gt;&gt; ds = pyasdf.ASDFDataSet(&quot;new_file.h5&quot;)</span>

<span class="sd">        One can add an event either by passing a filename ...</span>

<span class="sd">        &gt;&gt;&gt; ds.add_quakeml(&quot;/path/to/quake.xml&quot;)</span>

<span class="sd">        ... or by passing an existing event or catalog object.</span>

<span class="sd">        &gt;&gt;&gt; cat = obspy.read_events(&quot;/path/to/quakem.xml&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ds.add_quakeml(cat)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">obspy</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">Event</span><span class="p">):</span>
            <span class="n">cat</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">Catalog</span><span class="p">(</span><span class="n">events</span><span class="o">=</span><span class="p">[</span><span class="n">event</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">obspy</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">Catalog</span><span class="p">):</span>
            <span class="n">cat</span> <span class="o">=</span> <span class="n">event</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cat</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">read_events</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;quakeml&quot;</span><span class="p">)</span>

        <span class="n">old_cat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span>
        <span class="n">existing_resource_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">_i</span><span class="o">.</span><span class="n">resource_id</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="n">old_cat</span><span class="p">])</span>
        <span class="n">new_resource_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">_i</span><span class="o">.</span><span class="n">resource_id</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="n">cat</span><span class="p">])</span>
        <span class="n">intersection</span> <span class="o">=</span> <span class="n">existing_resource_ids</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">new_resource_ids</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">intersection</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Event id(s) </span><span class="si">%s</span><span class="s2"> already present in ASDF file. Adding events cancelled&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">intersection</span><span class="p">))</span>
        <span class="n">old_cat</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">cat</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">old_cat</span></div>


<div class="viewcode-block" id="ASDFDataSet.get_data_for_tag">
<a class="viewcode-back" href="../../asdf_data_set.html#pyasdf.asdf_data_set.ASDFDataSet.get_data_for_tag">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_data_for_tag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">station_name</span><span class="p">,</span> <span class="n">tag</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the waveform and station data for the requested station and</span>
<span class="sd">        path.</span>

<span class="sd">        :param station_name: A string with network id and station id,</span>
<span class="sd">            e.g. ``&quot;IU.ANMO&quot;``</span>
<span class="sd">        :type station_name: str</span>
<span class="sd">        :param tag: The path of the waveform.</span>
<span class="sd">        :type tag: str</span>
<span class="sd">        :return: tuple of the waveform and the inventory.</span>
<span class="sd">        :rtype: (:class:`~obspy.core.stream.Stream`,</span>
<span class="sd">                 :class:`~obspy.core.inventory.inventory.Inventory`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">station_name</span> <span class="o">=</span> <span class="n">station_name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span>
        <span class="n">station</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">waveforms</span><span class="p">,</span> <span class="n">station_name</span><span class="p">)</span>
        <span class="n">st</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">station</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span>
        <span class="n">inv</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">station</span><span class="p">,</span> <span class="s2">&quot;StationXML&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="s2">&quot;StationXML&quot;</span> <span class="ow">in</span> <span class="n">station</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">st</span><span class="p">,</span> <span class="n">inv</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_get_idx_and_size_estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waveform_name</span><span class="p">,</span> <span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span><span class="p">):</span>
        <span class="n">network</span><span class="p">,</span> <span class="n">station</span> <span class="o">=</span> <span class="n">waveform_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__file</span><span class="p">[</span><span class="s2">&quot;Waveforms&quot;</span><span class="p">][</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">network</span><span class="p">,</span> <span class="n">station</span><span class="p">)][</span><span class="n">waveform_name</span><span class="p">]</span>

        <span class="n">idx_start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">idx_end</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;sampling_rate&quot;</span><span class="p">]</span>

        <span class="c1"># Starttime is a timestamp in nanoseconds.</span>
        <span class="c1"># Get time of first and time of last sample.</span>
        <span class="n">data_starttime</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">UTCDateTime</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">])</span> <span class="o">/</span> <span class="mf">1.0e9</span><span class="p">)</span>
        <span class="n">data_endtime</span> <span class="o">=</span> <span class="n">data_starttime</span> <span class="o">+</span> <span class="nb">float</span><span class="p">((</span><span class="n">idx_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span>

        <span class="c1"># Modify the data indices to restrict the data if necessary.</span>
        <span class="k">if</span> <span class="n">starttime</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">starttime</span> <span class="o">&gt;</span> <span class="n">data_starttime</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">((</span><span class="n">starttime</span> <span class="o">-</span> <span class="n">data_starttime</span><span class="p">)</span> <span class="o">//</span> <span class="n">dt</span><span class="p">))</span>
            <span class="n">idx_start</span> <span class="o">=</span> <span class="n">offset</span>
            <span class="c1"># Also modify the data_starttime here as it changes the actually</span>
            <span class="c1"># read data.</span>
            <span class="n">data_starttime</span> <span class="o">+=</span> <span class="n">offset</span> <span class="o">*</span> <span class="n">dt</span>
        <span class="k">if</span> <span class="n">endtime</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">endtime</span> <span class="o">&lt;</span> <span class="n">data_endtime</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">((</span><span class="n">data_endtime</span> <span class="o">-</span> <span class="n">endtime</span><span class="p">)</span> <span class="o">//</span> <span class="n">dt</span><span class="p">))</span>
            <span class="n">idx_end</span> <span class="o">-=</span> <span class="n">offset</span>

        <span class="c1"># Check the size against the limit.</span>
        <span class="n">array_size_in_mb</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx_end</span> <span class="o">-</span> <span class="n">idx_start</span><span class="p">)</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span> <span class="o">/</span> <span class="mf">1024.0</span> <span class="o">/</span> <span class="mf">1024.0</span>

        <span class="k">del</span> <span class="n">data</span>

        <span class="k">return</span> <span class="n">idx_start</span><span class="p">,</span> <span class="n">idx_end</span><span class="p">,</span> <span class="n">data_starttime</span><span class="p">,</span> <span class="n">array_size_in_mb</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_waveform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waveform_name</span><span class="p">,</span> <span class="n">starttime</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">endtime</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the waveform for a certain path name as a Trace object. For</span>
<span class="sd">        internal use only, use the dot accessors for outside access.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">network</span><span class="p">,</span> <span class="n">station</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">channel</span> <span class="o">=</span> <span class="n">waveform_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[:</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">channel</span> <span class="o">=</span> <span class="n">channel</span><span class="p">[:</span> <span class="n">channel</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">)]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__file</span><span class="p">[</span><span class="s2">&quot;Waveforms&quot;</span><span class="p">][</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">network</span><span class="p">,</span> <span class="n">station</span><span class="p">)][</span><span class="n">waveform_name</span><span class="p">]</span>
        <span class="c1"># Read once upfront to optmize a bit.</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>

        <span class="c1"># Only do the checks if the filesize actually allows for it as its</span>
        <span class="c1"># fairly expensive or if start or endtime are given.</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filesize</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_item_read_limit_in_mb</span> <span class="o">*</span> <span class="mi">1024</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">starttime</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">or</span> <span class="n">endtime</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="p">(</span>
                <span class="n">idx_start</span><span class="p">,</span>
                <span class="n">idx_end</span><span class="p">,</span>
                <span class="n">data_starttime</span><span class="p">,</span>
                <span class="n">array_size_in_mb</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_idx_and_size_estimate</span><span class="p">(</span>  <span class="c1"># NOQA</span>
                <span class="n">waveform_name</span><span class="p">,</span> <span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">array_size_in_mb</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_item_read_limit_in_mb</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;The current selection would read </span><span class="si">%.2f</span><span class="s2"> MB into memory &quot;</span>
                    <span class="s2">&quot;from &#39;</span><span class="si">%s</span><span class="s2">&#39;. The current limit is </span><span class="si">%.2f</span><span class="s2"> MB. Adjust by &quot;</span>
                    <span class="s2">&quot;setting &#39;ASDFDataSet.single_item_read_limit_in_mb&#39; or &quot;</span>
                    <span class="s2">&quot;use a different method to read the waveform data.&quot;</span>
                    <span class="o">%</span> <span class="p">(</span>
                        <span class="n">array_size_in_mb</span><span class="p">,</span>
                        <span class="n">waveform_name</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">single_item_read_limit_in_mb</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="n">ASDFValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx_start</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">idx_end</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">data_starttime</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">UTCDateTime</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">])</span> <span class="o">/</span> <span class="mf">1.0e9</span><span class="p">)</span>

        <span class="n">tr</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">Trace</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="n">idx_start</span><span class="p">:</span><span class="n">idx_end</span><span class="p">])</span>
        <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">=</span> <span class="n">data_starttime</span>
        <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">=</span> <span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;sampling_rate&quot;</span><span class="p">]</span>
        <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="n">network</span>
        <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">station</span> <span class="o">=</span> <span class="n">station</span>
        <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="n">location</span>
        <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span> <span class="o">=</span> <span class="n">channel</span>
        <span class="c1"># Set some format specific details.</span>
        <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">_format</span> <span class="o">=</span> <span class="n">FORMAT_NAME</span>
        <span class="n">details</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">AttribDict</span><span class="p">()</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="p">,</span> <span class="n">FORMAT_NAME</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">details</span><span class="p">)</span>
        <span class="n">details</span><span class="o">.</span><span class="n">format_version</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">asdf_format_version</span>

        <span class="c1"># Read all the ids if they are there.</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;event_id&quot;</span><span class="p">,</span> <span class="s2">&quot;origin_id&quot;</span><span class="p">,</span> <span class="s2">&quot;magnitude_id&quot;</span><span class="p">,</span> <span class="s2">&quot;focal_mechanism_id&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span>
                    <span class="n">details</span><span class="p">,</span>
                    <span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;s&quot;</span><span class="p">,</span>
                    <span class="p">[</span>
                        <span class="n">obspy</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">ResourceIdentifier</span><span class="p">(</span><span class="n">_i</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
                    <span class="p">],</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;provenance_id&quot;</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">:</span>
            <span class="n">details</span><span class="o">.</span><span class="n">provenance_id</span> <span class="o">=</span> <span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;provenance_id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>

        <span class="k">if</span> <span class="s2">&quot;labels&quot;</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">:</span>
            <span class="n">details</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">labelstring2list</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;labels&quot;</span><span class="p">])</span>

        <span class="c1"># Add the tag to the stats dictionary.</span>
        <span class="n">details</span><span class="o">.</span><span class="n">tag</span> <span class="o">=</span> <span class="n">wf_name2tag</span><span class="p">(</span><span class="n">waveform_name</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tr</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_auxiliary_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">tag</span><span class="p">):</span>
        <span class="n">group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_auxiliary_data_group</span><span class="p">[</span><span class="n">data_type</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">h5py</span><span class="o">.</span><span class="n">Group</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">AuxiliaryDataAccessor</span><span class="p">(</span>
                <span class="n">auxiliary_data_type</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^/AuxiliaryData/&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">group</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
                <span class="n">asdf_data_set</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">AuxiliaryDataContainer</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">group</span><span class="p">,</span>
            <span class="n">data_type</span><span class="o">=</span><span class="n">data_type</span><span class="p">,</span>
            <span class="n">tag</span><span class="o">=</span><span class="n">tag</span><span class="p">,</span>
            <span class="n">parameters</span><span class="o">=</span><span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">j</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">group</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">()},</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">filesize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the current size of the file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getsize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">pretty_filesize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a pretty string representation of the size of the file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">sizeof_fmt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filesize</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pretty string formatting.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">FORMAT_NAME</span><span class="si">}</span><span class="s2"> file [format version: &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">asdf_format_version_in_file</span><span class="si">}</span><span class="s2">]: &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">relpath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39; (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pretty_filesize</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="p">)</span>
        <span class="n">ret</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">Contains </span><span class="si">%i</span><span class="s2"> event(s)&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">Contains waveform data from </span><span class="si">{len}</span><span class="s2"> station(s).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">len</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__file</span><span class="p">[</span><span class="s2">&quot;Waveforms&quot;</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">auxiliary_data</span><span class="p">):</span>
            <span class="n">ret</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">Contains </span><span class="si">%i</span><span class="s2"> type(s) of auxiliary data: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">auxiliary_data</span><span class="p">),</span>
                <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">auxiliary_data</span><span class="o">.</span><span class="n">list</span><span class="p">())),</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_repr_pretty_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">cycle</span><span class="p">):</span>
        <span class="n">p</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">())</span>

<div class="viewcode-block" id="ASDFDataSet.append_waveforms">
<a class="viewcode-back" href="../../asdf_data_set.html#pyasdf.asdf_data_set.ASDFDataSet.append_waveforms">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">append_waveforms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waveform</span><span class="p">,</span> <span class="n">tag</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Append waveforms to an existing data array if possible.</span>

<span class="sd">        .. note::</span>

<span class="sd">            The :meth:`.add_waveforms` method is the better choice in most</span>
<span class="sd">            cases. This function here is only useful for special cases!</span>

<span class="sd">        The main purpose of this function is to enable the construction of</span>
<span class="sd">        ASDF files with large single arrays. The classical example is all</span>
<span class="sd">        recordings of a station for a year or longer. If the</span>
<span class="sd">        :meth:`.add_waveforms` method is used ASDF will internally store</span>
<span class="sd">        each file in one or more data sets. This function here will attempt</span>
<span class="sd">        to enlarge existing data arrays and append to them creating larger</span>
<span class="sd">        ones that are a bit more efficient to read. It is slower to write</span>
<span class="sd">        this way but it can potentially be faster to read.</span>

<span class="sd">        This is only possible if the to be appended waveform traces</span>
<span class="sd">        seamlessly fit after an existing trace with a tolerance of half a</span>
<span class="sd">        sampling interval.</span>

<span class="sd">        Please note that a single array in ASDF cannot have any gaps and/or</span>
<span class="sd">        overlaps so even if this function is used it might still result in</span>
<span class="sd">        several data sets in the HDF5 file.</span>

<span class="sd">        This additionally requires that the data-sets being appended to have</span>
<span class="sd">        chunks as non-chunked data cannot be resized. MPI is consequently</span>
<span class="sd">        not allowed for this function as well.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            Any potentially set `event_id`, `origin_id`, `magnitude_id`,</span>
<span class="sd">            `focal_mechanism_id`, `provenance_id`, or `labels` will carry over</span>
<span class="sd">            from the trace that is being appended to so please only use this</span>
<span class="sd">            method if you known what you are doing.</span>


<span class="sd">        .. rubric:: Example</span>

<span class="sd">        Assuming three trace in three different files, ``A``, ``B``,</span>
<span class="sd">        and ``C``, that could seamlessly be merged to one big trace</span>
<span class="sd">        without producing a gap or overlap. Using :meth:`.add_waveforms`</span>
<span class="sd">        will create three seperate data arrays in the ASDF file, e.g.</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            ds.add_waveforms(A, tag=&quot;random&quot;)</span>
<span class="sd">            ds.add_waveforms(B, tag=&quot;random&quot;)</span>
<span class="sd">            ds.add_waveforms(C, tag=&quot;random&quot;)</span>

<span class="sd">        results in:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            /Waveforms</span>
<span class="sd">                /XX.YYYY</span>
<span class="sd">                    A</span>
<span class="sd">                    B</span>
<span class="sd">                    C</span>

<span class="sd">        Using this method here on the other hand will (if possible) create a</span>
<span class="sd">        single large array which might be a bit faster to read or to iterate</span>
<span class="sd">        over.</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            ds.append_waveforms(A, tag=&quot;random&quot;)</span>
<span class="sd">            ds.append_waveforms(B, tag=&quot;random&quot;)</span>
<span class="sd">            ds.append_waveforms(C, tag=&quot;random&quot;)</span>

<span class="sd">        This results in:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            /Waveforms</span>
<span class="sd">                /XX.YYYY</span>
<span class="sd">                    A + B + C</span>

<span class="sd">        :param waveform: The waveform to add. Can either be an ObsPy Stream</span>
<span class="sd">            or Trace object or something ObsPy can read.</span>
<span class="sd">        :type waveform: :class:`obspy.core.stream.Stream`,</span>
<span class="sd">            :class:`obspy.core.trace.Trace`, str, ...</span>
<span class="sd">        :param tag: The path that will be given to all waveform files. It is</span>
<span class="sd">            mandatory for all traces and facilitates identification of the data</span>
<span class="sd">            within one ASDF volume. The ``&quot;raw_record&quot;`` path is,</span>
<span class="sd">            by convention, reserved to raw, recorded, unprocessed data.</span>
<span class="sd">        :type tag: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ASDFException</span><span class="p">(</span><span class="s2">&quot;This function cannot work with parallel MPI I/O.&quot;</span><span class="p">)</span>

        <span class="n">tag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parse_and_validate_tag</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
        <span class="n">waveform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parse_waveform_input_and_validate</span><span class="p">(</span><span class="n">waveform</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_get_dataset_within_tolerance</span><span class="p">(</span><span class="n">station_group</span><span class="p">,</span> <span class="n">trace</span><span class="p">):</span>
            <span class="c1"># Tolerance.</span>
            <span class="n">min_t</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span>
            <span class="n">max_t</span> <span class="o">=</span> <span class="n">min_t</span> <span class="o">+</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span>

            <span class="n">i</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">id</span> <span class="o">+</span> <span class="s2">&quot;__&quot;</span>
            <span class="k">for</span> <span class="n">ds_name</span> <span class="ow">in</span> <span class="n">station_group</span><span class="o">.</span><span class="n">list</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ds_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">ds</span> <span class="o">=</span> <span class="n">station_group</span><span class="o">.</span><span class="n">_WaveformAccessor__hdf5_group</span><span class="p">[</span><span class="n">ds_name</span><span class="p">]</span>
                <span class="n">t</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">ds</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1e9</span>
                    <span class="o">+</span> <span class="n">ds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">ds</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;sampling_rate&quot;</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="k">del</span> <span class="n">ds</span>
                <span class="k">if</span> <span class="n">min_t</span> <span class="o">&lt;=</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="n">max_t</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">ds_name</span>

        <span class="k">for</span> <span class="n">trace</span> <span class="ow">in</span> <span class="n">waveform</span><span class="p">:</span>
            <span class="c1"># The logic is quite easy - find an existing data-set that is</span>
            <span class="c1"># within the allowed tolerance and append, otherwise just pass</span>
            <span class="c1"># to the add_waveforms() method.</span>
            <span class="n">sta_name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">network</span><span class="p">,</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">station</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sta_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__file</span><span class="p">[</span><span class="s2">&quot;Waveforms&quot;</span><span class="p">]:</span>
                <span class="n">ds_name</span> <span class="o">=</span> <span class="n">_get_dataset_within_tolerance</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">waveforms</span><span class="p">[</span><span class="n">sta_name</span><span class="p">],</span> <span class="n">trace</span><span class="o">=</span><span class="n">trace</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">ds_name</span><span class="p">:</span>
                    <span class="c1"># Append!</span>
                    <span class="n">sta_group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__file</span><span class="p">[</span><span class="s2">&quot;Waveforms&quot;</span><span class="p">][</span><span class="n">sta_name</span><span class="p">]</span>
                    <span class="n">ds</span> <span class="o">=</span> <span class="n">sta_group</span><span class="p">[</span><span class="n">ds_name</span><span class="p">]</span>

                    <span class="c1"># Make sure it actually can be resized.</span>
                    <span class="k">if</span> <span class="n">ds</span><span class="o">.</span><span class="n">maxshape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="s2">&quot;&#39;maxshape&#39; of &#39;</span><span class="si">%s</span><span class="s2">&#39; is not set to None which &quot;</span>
                            <span class="s2">&quot;prevents it from being resized.&quot;</span> <span class="o">%</span> <span class="n">ds_name</span>
                        <span class="p">)</span>
                        <span class="k">raise</span> <span class="n">ASDFValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">ds</span><span class="o">.</span><span class="n">chunks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="s2">&quot;Data set &#39;</span><span class="si">%s</span><span class="s2">&#39; is not chunked which &quot;</span>
                            <span class="s2">&quot;prevents it from being resized.&quot;</span> <span class="o">%</span> <span class="n">ds_name</span>
                        <span class="p">)</span>
                        <span class="k">raise</span> <span class="n">ASDFValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                    <span class="n">existing</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="c1"># Resize.</span>
                    <span class="n">ds</span><span class="o">.</span><span class="n">resize</span><span class="p">((</span><span class="n">existing</span> <span class="o">+</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span><span class="p">,))</span>
                    <span class="c1"># Add data.</span>
                    <span class="n">ds</span><span class="p">[</span><span class="n">existing</span><span class="p">:]</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">data</span>

                    <span class="c1"># Rename.</span>
                    <span class="n">new_data_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_waveform_ds_name</span><span class="p">(</span>
                        <span class="n">net</span><span class="o">=</span><span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">network</span><span class="p">,</span>
                        <span class="n">sta</span><span class="o">=</span><span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">station</span><span class="p">,</span>
                        <span class="n">loc</span><span class="o">=</span><span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">location</span><span class="p">,</span>
                        <span class="n">cha</span><span class="o">=</span><span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span><span class="p">,</span>
                        <span class="n">start</span><span class="o">=</span><span class="n">obspy</span><span class="o">.</span><span class="n">UTCDateTime</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1e9</span><span class="p">),</span>
                        <span class="n">end</span><span class="o">=</span><span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span><span class="p">,</span>
                        <span class="n">tag</span><span class="o">=</span><span class="n">tag</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">del</span> <span class="n">ds</span>

                    <span class="c1"># This does not copy data but just changes the name.</span>
                    <span class="k">if</span> <span class="n">new_data_name</span> <span class="o">!=</span> <span class="n">ds_name</span><span class="p">:</span>
                        <span class="n">sta_group</span><span class="p">[</span><span class="n">new_data_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">sta_group</span><span class="p">[</span><span class="n">ds_name</span><span class="p">]</span>
                        <span class="k">del</span> <span class="n">sta_group</span><span class="p">[</span><span class="n">ds_name</span><span class="p">]</span>

                    <span class="k">del</span> <span class="n">sta_group</span>
                    <span class="k">continue</span>

            <span class="c1"># If this did not work - append.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_waveforms</span><span class="p">(</span><span class="n">waveform</span><span class="o">=</span><span class="n">trace</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">tag</span><span class="p">)</span></div>


<div class="viewcode-block" id="ASDFDataSet.add_waveforms">
<a class="viewcode-back" href="../../asdf_data_set.html#pyasdf.asdf_data_set.ASDFDataSet.add_waveforms">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_waveforms</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">waveform</span><span class="p">,</span>
        <span class="n">tag</span><span class="p">,</span>
        <span class="n">event_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">origin_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">magnitude_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">focal_mechanism_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">provenance_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds one or more waveforms to the current ASDF file.</span>

<span class="sd">        :param waveform: The waveform to add. Can either be an ObsPy Stream or</span>
<span class="sd">            Trace object or something ObsPy can read.</span>
<span class="sd">        :type waveform: :class:`obspy.core.stream.Stream`,</span>
<span class="sd">            :class:`obspy.core.trace.Trace`, str, ...</span>
<span class="sd">        :param tag: The path that will be given to all waveform files. It is</span>
<span class="sd">            mandatory for all traces and facilitates identification of the data</span>
<span class="sd">            within one ASDF volume. The ``&quot;raw_record&quot;`` path is,</span>
<span class="sd">            by convention, reserved to raw, recorded, unprocessed data.</span>
<span class="sd">        :type tag: str</span>
<span class="sd">        :param event_id: The event or id which the waveform is associated</span>
<span class="sd">            with. This is useful for recorded data if a clear association is</span>
<span class="sd">            given, but also for synthetic data. Can also be a list of items.</span>
<span class="sd">        :type event_id: :class:`obspy.core.event.Event`,</span>
<span class="sd">            :class:`obspy.core.event.ResourceIdentifier`, str, or list</span>
<span class="sd">        :param origin_id: The particular origin this waveform is associated</span>
<span class="sd">            with. This is mainly useful for synthetic data where the origin</span>
<span class="sd">            is precisely known. Can also be a list of items.</span>
<span class="sd">        :type origin_id: :class:`obspy.core.event.Origin`,</span>
<span class="sd">            :class:`obspy.core.event.ResourceIdentifier`, str, or list</span>
<span class="sd">        :param magnitude_id: The particular magnitude this waveform is</span>
<span class="sd">            associated with. This is mainly useful for synthetic data where</span>
<span class="sd">            the magnitude is precisely known. Can also be a list of items.</span>
<span class="sd">        :type magnitude_id: :class:`obspy.core.event.Magnitude`,</span>
<span class="sd">            :class:`obspy.core.event.ResourceIdentifier`, str, or list</span>
<span class="sd">        :param focal_mechanism_id: The particular focal mechanism this</span>
<span class="sd">            waveform is associated with. This is mainly useful for synthetic</span>
<span class="sd">            data where the mechanism is precisely known. Can also be a list of</span>
<span class="sd">            items.</span>
<span class="sd">        :type focal_mechanism_id: :class:`obspy.core.event.FocalMechanism`,</span>
<span class="sd">            :class:`obspy.core.event.ResourceIdentifier`, str, or list</span>
<span class="sd">        :param provenance_id: The id of the provenance of this data. The</span>
<span class="sd">            provenance information itself must be added separately. Must be</span>
<span class="sd">            given as a qualified name, e.g. ``&#39;{namespace_uri}id&#39;``.</span>
<span class="sd">        :type labels: list of str</span>
<span class="sd">        :param labels: A list of labels to associate with all the added</span>
<span class="sd">            traces. Must not contain a comma as that is used as a separator.</span>

<span class="sd">        .. rubric:: Examples</span>

<span class="sd">        We first setup an example ASDF file with a single event.</span>

<span class="sd">        &gt;&gt;&gt; from pyasdf import ASDFDataSet</span>
<span class="sd">        &gt;&gt;&gt; ds = ASDFDataSet(&quot;event_tests.h5&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ds.add_quakeml(&quot;quake.xml&quot;)</span>
<span class="sd">        &gt;&gt;&gt; event = ds.events[0]</span>

<span class="sd">        Now assume we have a MiniSEED file that is an unprocessed</span>
<span class="sd">        observation of that earthquake straight from a datacenter called</span>
<span class="sd">        ``recording.mseed``. We will now add it to the file, give it the</span>
<span class="sd">        ``&quot;raw_recording&quot;`` path (which is reserved for raw, recorded,</span>
<span class="sd">        and unproceseed data) and associate it with the event. Keep in mind</span>
<span class="sd">        that this association is optional. It can also be associated with</span>
<span class="sd">        multiple events - in that case just pass a list of objects.</span>

<span class="sd">        &gt;&gt;&gt; ds.add_waveforms(&quot;recording.mseed&quot;, path=&quot;raw_recording&quot;,</span>
<span class="sd">        ...                  event_id=event)</span>

<span class="sd">        It is also possible to directly add</span>
<span class="sd">        :class:`obspy.core.stream.Stream` objects containing an arbitrary</span>
<span class="sd">        number of :class:`obspy.core.trace.Trace` objects.</span>

<span class="sd">        &gt;&gt;&gt; import obspy</span>
<span class="sd">        &gt;&gt;&gt; st = obspy.read()  # Reads an example file without argument.</span>
<span class="sd">        &gt;&gt;&gt; print(st)</span>
<span class="sd">        3 Trace(s) in Stream:</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:03.00Z - ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        BW.RJOB..EHN | 2009-08-24T00:20:03.00Z - ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        BW.RJOB..EHE | 2009-08-24T00:20:03.00Z - ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        &gt;&gt;&gt; ds.add_waveforms(st, path=&quot;obspy_example&quot;)</span>

<span class="sd">        Just to demonstrate that all waveforms can also be retrieved again.</span>

<span class="sd">        &gt;&gt;&gt; print(print(ds.waveforms.BW_RJOB.obspy_example))</span>
<span class="sd">        3 Trace(s) in Stream:</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:03.00Z - ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        BW.RJOB..EHN | 2009-08-24T00:20:03.00Z - ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        BW.RJOB..EHE | 2009-08-24T00:20:03.00Z - ... | 100.0 Hz, 3000 samples</span>

<span class="sd">        For the last example lets assume we have the result of a simulation</span>
<span class="sd">        stored in the ``synthetics.sac`` file. In this case we know the</span>
<span class="sd">        precise source parameters (we specified them before running the</span>
<span class="sd">        simulation) so it is a good idea to add that association to the</span>
<span class="sd">        waveform. Please again keep in mind that they are all optional and</span>
<span class="sd">        depending on your use case they might or might not be</span>
<span class="sd">        useful/meaningful. You can again pass lists of all of these objects</span>
<span class="sd">        in which case multiple associations will be stored in the file.</span>

<span class="sd">        &gt;&gt;&gt; origin = event.preferred_origin()</span>
<span class="sd">        &gt;&gt;&gt; magnitude = event.preferred_magnitude()</span>
<span class="sd">        &gt;&gt;&gt; focal_mechanism = event.preferred_focal_mechansism()</span>
<span class="sd">        &gt;&gt;&gt; ds.add_waveforms(&quot;synthetics.sac&quot;, event_id=event,</span>
<span class="sd">        ...                  origin_id=origin, magnitude_id=magnitude,</span>
<span class="sd">        ...                  focal_mechanism_id=focal_mechanism)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">provenance_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Will raise an error if not a valid qualified name.</span>
            <span class="n">split_qualified_name</span><span class="p">(</span><span class="n">provenance_id</span><span class="p">)</span>

        <span class="c1"># Parse labels to a single comma separated string.</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">label2string</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>

        <span class="n">tag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parse_and_validate_tag</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
        <span class="n">waveform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parse_waveform_input_and_validate</span><span class="p">(</span><span class="n">waveform</span><span class="p">)</span>

        <span class="c1"># Actually add the data.</span>
        <span class="k">for</span> <span class="n">trace</span> <span class="ow">in</span> <span class="n">waveform</span><span class="p">:</span>
            <span class="c1"># Complicated multi-step process but it enables one to use</span>
            <span class="c1"># parallel I/O with the same functions.</span>
            <span class="n">info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_trace_get_collective_information</span><span class="p">(</span>
                <span class="n">trace</span><span class="p">,</span>
                <span class="n">tag</span><span class="p">,</span>
                <span class="n">event_id</span><span class="o">=</span><span class="n">event_id</span><span class="p">,</span>
                <span class="n">origin_id</span><span class="o">=</span><span class="n">origin_id</span><span class="p">,</span>
                <span class="n">magnitude_id</span><span class="o">=</span><span class="n">magnitude_id</span><span class="p">,</span>
                <span class="n">focal_mechanism_id</span><span class="o">=</span><span class="n">focal_mechanism_id</span><span class="p">,</span>
                <span class="n">provenance_id</span><span class="o">=</span><span class="n">provenance_id</span><span class="p">,</span>
                <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_trace_write_collective_information</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_trace_write_independent_information</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">trace</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">__parse_and_validate_tag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">):</span>
        <span class="n">tag</span> <span class="o">=</span> <span class="n">tag</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">tag</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;stationxml&quot;</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Tag &#39;</span><span class="si">%s</span><span class="s2">&#39; is invalid.&quot;</span> <span class="o">%</span> <span class="n">tag</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tag</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__parse_waveform_input_and_validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waveform</span><span class="p">):</span>
        <span class="c1"># The next function expects some kind of iterable that yields traces.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">waveform</span><span class="p">,</span> <span class="n">obspy</span><span class="o">.</span><span class="n">Trace</span><span class="p">):</span>
            <span class="n">waveform</span> <span class="o">=</span> <span class="p">[</span><span class="n">waveform</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">waveform</span><span class="p">,</span> <span class="n">obspy</span><span class="o">.</span><span class="n">Stream</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="c1"># Delegate to ObsPy&#39;s format/input detection.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">waveform</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">waveform</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">trace</span> <span class="ow">in</span> <span class="n">waveform</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">trace</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="n">VALID_SEISMOGRAM_DTYPES</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">asdf_format_version</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">asdf_format_version</span> <span class="o">==</span> <span class="s2">&quot;1.0.0&quot;</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;The trace&#39;s dtype (&#39;</span><span class="si">%s</span><span class="s2">&#39;) is not allowed &quot;</span>
                        <span class="s2">&quot;inside ASDF 1.0.0. Allowed are little &quot;</span>
                        <span class="s2">&quot;and big endian 4 and 8 byte signed &quot;</span>
                        <span class="s2">&quot;integers and floating point numbers.&quot;</span> <span class="o">%</span> <span class="n">trace</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">asdf_format_version</span> <span class="o">==</span> <span class="s2">&quot;1.0.1&quot;</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;The trace&#39;s dtype (&#39;</span><span class="si">%s</span><span class="s2">&#39;) is not allowed &quot;</span>
                        <span class="s2">&quot;inside ASDF 1.0.1. Allowed are little &quot;</span>
                        <span class="s2">&quot;and big endian 2, 4, and 8 byte signed &quot;</span>
                        <span class="s2">&quot;integers and 4 and 8 byte floating point &quot;</span>
                        <span class="s2">&quot;numbers.&quot;</span> <span class="o">%</span> <span class="n">trace</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">asdf_format_version</span> <span class="o">==</span> <span class="s2">&quot;1.0.2&quot;</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;The trace&#39;s dtype (&#39;</span><span class="si">%s</span><span class="s2">&#39;) is not allowed &quot;</span>
                        <span class="s2">&quot;inside ASDF 1.0.2. Allowed are little &quot;</span>
                        <span class="s2">&quot;and big endian 2, 4, and 8 byte signed &quot;</span>
                        <span class="s2">&quot;integers and 4 and 8 byte floating point &quot;</span>
                        <span class="s2">&quot;numbers.&quot;</span> <span class="o">%</span> <span class="n">trace</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">asdf_format_version</span> <span class="o">==</span> <span class="s2">&quot;1.0.3&quot;</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;The trace&#39;s dtype (&#39;</span><span class="si">%s</span><span class="s2">&#39;) is not allowed &quot;</span>
                        <span class="s2">&quot;inside ASDF 1.0.3. Allowed are little &quot;</span>
                        <span class="s2">&quot;and big endian 2, 4, and 8 byte signed &quot;</span>
                        <span class="s2">&quot;integers and 4 and 8 byte floating point &quot;</span>
                        <span class="s2">&quot;numbers.&quot;</span> <span class="o">%</span> <span class="n">trace</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="k">return</span> <span class="n">waveform</span>

<div class="viewcode-block" id="ASDFDataSet.get_provenance_document">
<a class="viewcode-back" href="../../asdf_data_set.html#pyasdf.asdf_data_set.ASDFDataSet.get_provenance_document">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_provenance_document</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">document_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve a provenance document with a certain name.</span>

<span class="sd">        :param document_name: The name of the provenance document to retrieve.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">document_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_provenance_group</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ASDFValueError</span><span class="p">(</span>
                <span class="s2">&quot;Provenance document &#39;</span><span class="si">%s</span><span class="s2">&#39; not found in file.&quot;</span> <span class="o">%</span> <span class="n">document_name</span>
            <span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_provenance_group</span><span class="p">[</span><span class="n">document_name</span><span class="p">]</span>

        <span class="k">with</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">_read_string_array</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="k">as</span> <span class="n">buf</span><span class="p">:</span>
            <span class="n">doc</span> <span class="o">=</span> <span class="n">prov</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;xml&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">doc</span></div>


<div class="viewcode-block" id="ASDFDataSet.add_provenance_document">
<a class="viewcode-back" href="../../asdf_data_set.html#pyasdf.asdf_data_set.ASDFDataSet.add_provenance_document">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_provenance_document</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">document</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a provenance document to the current ASDF file.</span>

<span class="sd">        :type document: Filename, file-like objects or prov document.</span>
<span class="sd">        :param document: The document to add.</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param name: The name of the document within ASDF. Must be lowercase</span>
<span class="sd">            alphanumeric with optional underscores. If not given, it will</span>
<span class="sd">            autogenerate one. If given and it already exists, it will be</span>
<span class="sd">            overwritten.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Always open it. We will write it anew everytime. This enables</span>
        <span class="c1"># pyasdf to store everything the prov package can read.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">document</span><span class="p">,</span> <span class="n">prov</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">ProvDocument</span><span class="p">):</span>
            <span class="n">document</span> <span class="o">=</span> <span class="n">prov</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">document</span><span class="p">)</span>

        <span class="c1"># Autogenerate name if not given.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">())</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span>

        <span class="n">pattern</span> <span class="o">=</span> <span class="n">PROV_FILENAME_REGEX</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">asdf_format_version</span><span class="p">]</span>

        <span class="c1"># Assert the name against the regex.</span>
        <span class="k">if</span> <span class="n">pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ASDFValueError</span><span class="p">(</span>
                <span class="s2">&quot;Name &#39;</span><span class="si">%s</span><span class="s2">&#39; is invalid. It must validate &quot;</span>
                <span class="s2">&quot;against the regular expression &#39;</span><span class="si">%s</span><span class="s2">&#39; in ASDF version &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">pattern</span><span class="o">.</span><span class="n">pattern</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">asdf_format_version</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">with</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span> <span class="k">as</span> <span class="n">buf</span><span class="p">:</span>
            <span class="n">document</span><span class="o">.</span><span class="n">serialize</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;xml&quot;</span><span class="p">)</span>
            <span class="n">buf</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">buf</span><span class="o">.</span><span class="n">read</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;byte&quot;</span><span class="p">))</span>

        <span class="c1"># If it already exists, overwrite the existing one.</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_provenance_group</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_provenance_group</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_provenance_group</span><span class="p">[</span><span class="n">name</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># maxshape takes care to create an extendable data set.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_provenance_group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
                <span class="n">name</span><span class="p">,</span>
                <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                <span class="n">compression</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__compression</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">compression_opts</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__compression</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">shuffle</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__shuffle</span><span class="p">,</span>
                <span class="n">maxshape</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,),</span>
                <span class="n">fletcher32</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_add_trace_write_independent_information</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">trace</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes the independent part of a trace to the file.</span>

<span class="sd">        :param info:</span>
<span class="sd">        :param trace:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_waveform_group</span><span class="p">[</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;data_name&quot;</span><span class="p">]][:]</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">data</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_add_trace_write_collective_information</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes the collective part of a trace to the file.</span>

<span class="sd">        :param info:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">station_name</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s2">&quot;station_name&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">station_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_waveform_group</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_waveform_group</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">station_name</span><span class="p">)</span>
        <span class="n">group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_waveform_group</span><span class="p">[</span><span class="n">station_name</span><span class="p">]</span>

        <span class="c1"># workaround for a bug in hdf5 1.10 and PPC64</span>
        <span class="n">info</span><span class="p">[</span><span class="s2">&quot;dataset_creation_params&quot;</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">group</span>

        <span class="n">ds</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="o">**</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;dataset_creation_params&quot;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">info</span><span class="p">[</span><span class="s2">&quot;dataset_attrs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">ds</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__get_waveform_ds_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="n">sta</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">cha</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">tag</span><span class="p">):</span>
        <span class="n">fmt_string</span> <span class="o">=</span> <span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2">T%H:%M:%S&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="n">fmt_string</span><span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">end</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="n">fmt_string</span><span class="p">)</span>

        <span class="c1"># Add nanoseconds if two waveforms start in the same second. Only do</span>
        <span class="c1"># so for recent ASDF versions.</span>
        <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">e</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loose_asdf_format_version</span> <span class="o">&gt;=</span> <span class="n">packaging</span><span class="o">.</span><span class="n">version</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span>
            <span class="s2">&quot;1.0.2&quot;</span>
        <span class="p">):</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="si">%09i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">start</span><span class="o">.</span><span class="n">_ns</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1e9</span><span class="p">))</span>
            <span class="n">e</span> <span class="o">+=</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="si">%09i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">end</span><span class="o">.</span><span class="n">_ns</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1e9</span><span class="p">))</span>

        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">net</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">sta</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">cha</span><span class="si">}</span><span class="s2">__</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2">__</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">__</span><span class="si">{</span><span class="n">tag</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_add_trace_get_collective_information</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">trace</span><span class="p">,</span>
        <span class="n">tag</span><span class="p">,</span>
        <span class="n">event_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">origin_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">magnitude_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">focal_mechanism_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">provenance_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The information required for the collective part of adding a trace.</span>

<span class="sd">        This will extract the group name, the parameters of the dataset to</span>
<span class="sd">        be created, and the attributes of the dataset.</span>

<span class="sd">        :param trace: The trace to add.</span>
<span class="sd">        :param tag: The path of the trace.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Assert the tag.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">TAG_REGEX</span><span class="p">,</span> <span class="n">tag</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid tag: &#39;</span><span class="si">%s</span><span class="s2">&#39; - Must satisfy the regex &quot;</span>
                <span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">TAG_REGEX</span><span class="o">.</span><span class="n">pattern</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">station_name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">network</span><span class="p">,</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">station</span><span class="p">)</span>
        <span class="c1"># Generate the name of the data within its station folder.</span>
        <span class="n">data_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_waveform_ds_name</span><span class="p">(</span>
            <span class="n">net</span><span class="o">=</span><span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">network</span><span class="p">,</span>
            <span class="n">sta</span><span class="o">=</span><span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">station</span><span class="p">,</span>
            <span class="n">loc</span><span class="o">=</span><span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">location</span><span class="p">,</span>
            <span class="n">cha</span><span class="o">=</span><span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span><span class="p">,</span>
            <span class="n">start</span><span class="o">=</span><span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">,</span>
            <span class="n">end</span><span class="o">=</span><span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span><span class="p">,</span>
            <span class="n">tag</span><span class="o">=</span><span class="n">tag</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">group_name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">station_name</span><span class="p">,</span> <span class="n">data_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">group_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_waveform_group</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Data &#39;</span><span class="si">%s</span><span class="s2">&#39; already exists in file. Will not be added!&quot;</span> <span class="o">%</span> <span class="n">group_name</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">ASDFWarning</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Checksumming cannot be used when writing with MPI I/O.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="p">:</span>
            <span class="n">fletcher32</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fletcher32</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">info</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;station_name&quot;</span><span class="p">:</span> <span class="n">station_name</span><span class="p">,</span>
            <span class="s2">&quot;data_name&quot;</span><span class="p">:</span> <span class="n">group_name</span><span class="p">,</span>
            <span class="s2">&quot;dataset_creation_params&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">data_name</span><span class="p">,</span>
                <span class="s2">&quot;shape&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span><span class="p">,),</span>
                <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="n">trace</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                <span class="s2">&quot;compression&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__compression</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="s2">&quot;compression_opts&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__compression</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="s2">&quot;shuffle&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__shuffle</span><span class="p">,</span>
                <span class="s2">&quot;fletcher32&quot;</span><span class="p">:</span> <span class="n">fletcher32</span><span class="p">,</span>
                <span class="s2">&quot;maxshape&quot;</span><span class="p">:</span> <span class="p">(</span><span class="kc">None</span><span class="p">,),</span>
            <span class="p">},</span>
            <span class="s2">&quot;dataset_attrs&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="c1"># Starttime is the epoch time in nanoseconds.</span>
                <span class="s2">&quot;starttime&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">*</span> <span class="mf">1.0e9</span><span class="p">)),</span>
                <span class="s2">&quot;sampling_rate&quot;</span><span class="p">:</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">}</span>

        <span class="c1"># Add the labels if they are given. Given labels overwrite the one</span>
        <span class="c1"># in the attributes.</span>
        <span class="k">if</span> <span class="n">labels</span><span class="p">:</span>
            <span class="n">info</span><span class="p">[</span><span class="s2">&quot;dataset_attrs&quot;</span><span class="p">][</span><span class="s2">&quot;labels&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">labels</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="nb">hasattr</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="p">,</span> <span class="s2">&quot;asdf&quot;</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">asdf</span><span class="p">,</span> <span class="s2">&quot;labels&quot;</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">asdf</span><span class="o">.</span><span class="n">labels</span>
        <span class="p">):</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">label2string</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">asdf</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>
            <span class="n">info</span><span class="p">[</span><span class="s2">&quot;dataset_attrs&quot;</span><span class="p">][</span><span class="s2">&quot;labels&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">labels</span>

        <span class="c1"># The various ids can either be given as the objects themselves,</span>
        <span class="c1"># e.g. an event, an origin, a magnitude, or a focal mechansism.</span>
        <span class="c1"># Alternatively they can be passed as ResourceIdentifier objects or</span>
        <span class="c1"># anything that can be converted to a resource identifier. Always</span>
        <span class="c1"># either 0, 1, or more of them, in that case as part of an iterator.</span>
        <span class="c1"># After the next step they are all lists of ResourceIdentifiers.</span>
        <span class="n">event_id</span> <span class="o">=</span> <span class="n">to_list_of_resource_identifiers</span><span class="p">(</span>
            <span class="n">event_id</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;event_id&quot;</span><span class="p">,</span> <span class="n">obj_type</span><span class="o">=</span><span class="n">obspy</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">Event</span>
        <span class="p">)</span>
        <span class="n">origin_id</span> <span class="o">=</span> <span class="n">to_list_of_resource_identifiers</span><span class="p">(</span>
            <span class="n">origin_id</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;origin_id&quot;</span><span class="p">,</span> <span class="n">obj_type</span><span class="o">=</span><span class="n">obspy</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">Origin</span>
        <span class="p">)</span>
        <span class="n">magnitude_id</span> <span class="o">=</span> <span class="n">to_list_of_resource_identifiers</span><span class="p">(</span>
            <span class="n">magnitude_id</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;magnitude_id&quot;</span><span class="p">,</span>
            <span class="n">obj_type</span><span class="o">=</span><span class="n">obspy</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">Magnitude</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">focal_mechanism_id</span> <span class="o">=</span> <span class="n">to_list_of_resource_identifiers</span><span class="p">(</span>
            <span class="n">focal_mechanism_id</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;focal_mechanism_id&quot;</span><span class="p">,</span>
            <span class="n">obj_type</span><span class="o">=</span><span class="n">obspy</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">FocalMechanism</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Add all the event ids.</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;event_id&quot;</span><span class="p">:</span> <span class="n">event_id</span><span class="p">,</span>
            <span class="s2">&quot;origin_id&quot;</span><span class="p">:</span> <span class="n">origin_id</span><span class="p">,</span>
            <span class="s2">&quot;magnitude_id&quot;</span><span class="p">:</span> <span class="n">magnitude_id</span><span class="p">,</span>
            <span class="s2">&quot;focal_mechanism_id&quot;</span><span class="p">:</span> <span class="n">focal_mechanism_id</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">ids</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="p">,</span> <span class="s2">&quot;asdf&quot;</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">asdf</span><span class="p">,</span> <span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;s&quot;</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">asdf</span><span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;s&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">obj</span><span class="p">:</span>
                <span class="n">info</span><span class="p">[</span><span class="s2">&quot;dataset_attrs&quot;</span><span class="p">][</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zeropad_ascii_string</span><span class="p">(</span>
                    <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">_i</span><span class="o">.</span><span class="n">id</span><span class="p">)</span> <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="c1"># Set the provenance id. Either get the one from the arguments or</span>
        <span class="c1"># use the one already set in the trace.stats attribute.</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">provenance_id</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="p">,</span> <span class="s2">&quot;asdf&quot;</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">asdf</span><span class="p">,</span> <span class="s2">&quot;provenance_id&quot;</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">provenance_id</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">asdf</span><span class="p">[</span><span class="s2">&quot;provenance_id&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">provenance_id</span><span class="p">:</span>
            <span class="n">info</span><span class="p">[</span><span class="s2">&quot;dataset_attrs&quot;</span><span class="p">][</span><span class="s2">&quot;provenance_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zeropad_ascii_string</span><span class="p">(</span>
                <span class="nb">str</span><span class="p">(</span><span class="n">provenance_id</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">info</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_station</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">station_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the specified StationXML as an ObsPy Inventory object. For</span>
<span class="sd">        internal use only, use the dot accessors for external access.</span>

<span class="sd">        :param station_name: A string with network id and station id,</span>
<span class="sd">            e.g. ``&quot;IU.ANMO&quot;``</span>
<span class="sd">        :type station_name: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">station_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__file</span><span class="p">[</span><span class="s2">&quot;Waveforms&quot;</span><span class="p">]</span>
            <span class="ow">or</span> <span class="s2">&quot;StationXML&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__file</span><span class="p">[</span><span class="s2">&quot;Waveforms&quot;</span><span class="p">][</span><span class="n">station_name</span><span class="p">]</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__file</span><span class="p">[</span><span class="s2">&quot;Waveforms&quot;</span><span class="p">][</span><span class="n">station_name</span><span class="p">][</span><span class="s2">&quot;StationXML&quot;</span><span class="p">]</span>

        <span class="k">with</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">_read_string_array</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="k">as</span> <span class="n">buf</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">inv</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">read_inventory</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;stationxml&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">lxml</span><span class="o">.</span><span class="n">etree</span><span class="o">.</span><span class="n">XMLSyntaxError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Invalid XML file stored in the StationXML group for &quot;</span>
                    <span class="s2">&quot;station </span><span class="si">%s</span><span class="s2"> (HDF5 path &#39;/Waveforms/</span><span class="si">%s</span><span class="s2">/StationXML&#39;). Talk &quot;</span>
                    <span class="s2">&quot;to the person/program that created the file!&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">station_name</span><span class="p">,</span> <span class="n">station_name</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">inv</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_namespace_map_stationxml</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inv</span><span class="p">):</span>
        <span class="n">nsmap</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">inv</span><span class="p">,</span> <span class="s2">&quot;extra&quot;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">nsmap</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="s2">&quot;namespace&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">net</span> <span class="ow">in</span> <span class="n">inv</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="s2">&quot;extra&quot;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">nsmap</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="s2">&quot;namespace&quot;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">sta</span> <span class="ow">in</span> <span class="n">net</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">sta</span><span class="p">,</span> <span class="s2">&quot;extra&quot;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">nsmap</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="s2">&quot;namespace&quot;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">cha</span> <span class="ow">in</span> <span class="n">sta</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cha</span><span class="p">,</span> <span class="s2">&quot;extra&quot;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">nsmap</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="s2">&quot;namespace&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">nsmap</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_add_inventory_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inv</span><span class="p">,</span> <span class="n">network_id</span><span class="p">,</span> <span class="n">station_id</span><span class="p">):</span>
        <span class="n">station_name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">network_id</span><span class="p">,</span> <span class="n">station_id</span><span class="p">)</span>

        <span class="c1"># Write the station information to a numpy array that will then be</span>
        <span class="c1"># written to the HDF5 file.</span>
        <span class="k">with</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span> <span class="k">as</span> <span class="n">buf</span><span class="p">:</span>
            <span class="n">inv</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="n">buf</span><span class="p">,</span>
                <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;stationxml&quot;</span><span class="p">,</span>
                <span class="n">nsmap</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_namespace_map_stationxml</span><span class="p">(</span><span class="n">inv</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">buf</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">buf</span><span class="o">.</span><span class="n">read</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;byte&quot;</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">station_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_waveform_group</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_waveform_group</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">station_name</span><span class="p">)</span>
        <span class="n">station_group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_waveform_group</span><span class="p">[</span><span class="n">station_name</span><span class="p">]</span>

        <span class="c1"># If it already exists, overwrite the existing one.</span>
        <span class="k">if</span> <span class="s2">&quot;StationXML&quot;</span> <span class="ow">in</span> <span class="n">station_group</span><span class="p">:</span>
            <span class="n">station_group</span><span class="p">[</span><span class="s2">&quot;StationXML&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">station_group</span><span class="p">[</span><span class="s2">&quot;StationXML&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># maxshape takes care to create an extendable data set.</span>
            <span class="n">station_group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
                <span class="s2">&quot;StationXML&quot;</span><span class="p">,</span>
                <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                <span class="n">compression</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__compression</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">compression_opts</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__compression</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">shuffle</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__shuffle</span><span class="p">,</span>
                <span class="n">maxshape</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,),</span>
                <span class="n">fletcher32</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>

<div class="viewcode-block" id="ASDFDataSet.add_stationxml">
<a class="viewcode-back" href="../../asdf_data_set.html#pyasdf.asdf_data_set.ASDFDataSet.add_stationxml">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_stationxml</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stationxml</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds the StationXML to the data set object.</span>

<span class="sd">        This does some fairly exhaustive processing and will happily</span>
<span class="sd">        split the StationXML file and merge it with existing ones.</span>

<span class="sd">        If you care to have an a more or less unchanged StationXML file in</span>
<span class="sd">        the data set object be sure to add it one station at a time.</span>

<span class="sd">        :param stationxml: Filename of StationXML file or an ObsPy inventory</span>
<span class="sd">            object containing the same.</span>
<span class="sd">        :type stationxml: str or</span>
<span class="sd">            :class:`~obspy.core.inventory.inventory.Inventory`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If not already an inventory object, delegate to ObsPy and see if</span>
        <span class="c1"># it can read it.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stationxml</span><span class="p">,</span> <span class="n">obspy</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">inventory</span><span class="o">.</span><span class="n">inventory</span><span class="o">.</span><span class="n">Inventory</span><span class="p">):</span>
            <span class="n">stationxml</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">read_inventory</span><span class="p">(</span><span class="n">stationxml</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;stationxml&quot;</span><span class="p">)</span>

        <span class="c1"># Now we essentially walk the whole inventory, see what parts are</span>
        <span class="c1"># already available and add only the new ones. This involved quite a</span>
        <span class="c1"># bit of splitting and merging of the inventory objects.</span>
        <span class="n">network_station_codes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">network</span> <span class="ow">in</span> <span class="n">stationxml</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">station</span> <span class="ow">in</span> <span class="n">network</span><span class="p">:</span>
                <span class="n">network_station_codes</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">network</span><span class="o">.</span><span class="n">code</span><span class="p">,</span> <span class="n">station</span><span class="o">.</span><span class="n">code</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">network_id</span><span class="p">,</span> <span class="n">station_id</span> <span class="ow">in</span> <span class="n">network_station_codes</span><span class="p">:</span>
            <span class="n">station_name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">network_id</span><span class="p">,</span> <span class="n">station_id</span><span class="p">)</span>

            <span class="c1"># Get any existing station information.</span>
            <span class="n">existing_inventory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_station</span><span class="p">(</span><span class="n">station_name</span><span class="p">)</span>
            <span class="c1"># If it does not exist yet, make sure its well behaved and add it.</span>
            <span class="k">if</span> <span class="n">existing_inventory</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_inventory_object</span><span class="p">(</span>
                    <span class="n">inv</span><span class="o">=</span><span class="n">isolate_and_merge_station</span><span class="p">(</span>
                        <span class="n">stationxml</span><span class="p">,</span>
                        <span class="n">network_id</span><span class="o">=</span><span class="n">network_id</span><span class="p">,</span>
                        <span class="n">station_id</span><span class="o">=</span><span class="n">station_id</span><span class="p">,</span>
                    <span class="p">),</span>
                    <span class="n">network_id</span><span class="o">=</span><span class="n">network_id</span><span class="p">,</span>
                    <span class="n">station_id</span><span class="o">=</span><span class="n">station_id</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="c1"># Otherwise merge with the existing one and overwrite the</span>
            <span class="c1"># existing one.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_inventory_object</span><span class="p">(</span>
                    <span class="n">inv</span><span class="o">=</span><span class="n">merge_inventories</span><span class="p">(</span>
                        <span class="n">inv_a</span><span class="o">=</span><span class="n">existing_inventory</span><span class="p">,</span>
                        <span class="n">inv_b</span><span class="o">=</span><span class="n">stationxml</span><span class="p">,</span>
                        <span class="n">network_id</span><span class="o">=</span><span class="n">network_id</span><span class="p">,</span>
                        <span class="n">station_id</span><span class="o">=</span><span class="n">station_id</span><span class="p">,</span>
                    <span class="p">),</span>
                    <span class="n">network_id</span><span class="o">=</span><span class="n">network_id</span><span class="p">,</span>
                    <span class="n">station_id</span><span class="o">=</span><span class="n">station_id</span><span class="p">,</span>
                <span class="p">)</span></div>


<div class="viewcode-block" id="ASDFDataSet.validate">
<a class="viewcode-back" href="../../asdf_data_set.html#pyasdf.asdf_data_set.ASDFDataSet.validate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate and ASDF file. It currently checks that each waveform file</span>
<span class="sd">        has a corresponding station file.</span>

<span class="sd">        This does not (by far) replace the actual ASDF format validator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">summary</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;no_station_information&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;no_waveforms&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;good_stations&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="n">station</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">waveforms</span><span class="p">:</span>
            <span class="n">has_stationxml</span> <span class="o">=</span> <span class="s2">&quot;StationXML&quot;</span> <span class="ow">in</span> <span class="n">station</span>
            <span class="n">has_waveforms</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">station</span><span class="o">.</span><span class="n">get_waveform_tags</span><span class="p">())</span>

            <span class="k">if</span> <span class="n">has_stationxml</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">has_waveforms</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">elif</span> <span class="n">has_stationxml</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;No station information available for station &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span>
                    <span class="o">%</span> <span class="n">station</span><span class="o">.</span><span class="n">_station_name</span>
                <span class="p">)</span>
                <span class="n">summary</span><span class="p">[</span><span class="s2">&quot;no_station_information&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">has_waveforms</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Station with no waveforms: &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">station</span><span class="o">.</span><span class="n">_station_name</span><span class="p">)</span>
                <span class="n">summary</span><span class="p">[</span><span class="s2">&quot;no_waveforms&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">continue</span>
            <span class="n">summary</span><span class="p">[</span><span class="s2">&quot;good_stations&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Checked </span><span class="si">%i</span><span class="s2"> station(s):&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">waveforms</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="se">\t</span><span class="si">%i</span><span class="s2"> station(s) have no available station information&quot;</span>
            <span class="o">%</span> <span class="n">summary</span><span class="p">[</span><span class="s2">&quot;no_station_information&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="si">%i</span><span class="s2"> station(s) with no waveforms&quot;</span> <span class="o">%</span> <span class="n">summary</span><span class="p">[</span><span class="s2">&quot;no_waveforms&quot;</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="si">%i</span><span class="s2"> good station(s)&quot;</span> <span class="o">%</span> <span class="n">summary</span><span class="p">[</span><span class="s2">&quot;good_stations&quot;</span><span class="p">])</span></div>


<div class="viewcode-block" id="ASDFDataSet.ifilter">
<a class="viewcode-back" href="../../asdf_data_set.html#pyasdf.asdf_data_set.ASDFDataSet.ifilter">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">ifilter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">query_objects</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an iterator containing only the filtered information. Usage</span>
<span class="sd">        is fairly complex, a separate documentation page for</span>
<span class="sd">        :doc:`querying_data` is available - here is just a quick example:</span>

<span class="sd">        &gt;&gt;&gt; for station in ds.ifilter(ds.q.network == &quot;B?&quot;,</span>
<span class="sd">        ...                           ds.q.channel == &quot;*Z&quot;,</span>
<span class="sd">        ...                           ds.q.starttime &gt;= &quot;2015-01-01&quot;)</span>
<span class="sd">        ...     ...</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">queries</span> <span class="o">=</span> <span class="n">merge_query_functions</span><span class="p">(</span><span class="n">query_objects</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">station</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">waveforms</span><span class="p">:</span>
            <span class="c1"># Cheap checks first.</span>
            <span class="c1"># Test network and station codes if either is given.</span>
            <span class="k">if</span> <span class="n">queries</span><span class="p">[</span><span class="s2">&quot;network&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">queries</span><span class="p">[</span><span class="s2">&quot;station&quot;</span><span class="p">]:</span>
                <span class="n">net_code</span><span class="p">,</span> <span class="n">sta_code</span> <span class="o">=</span> <span class="n">station</span><span class="o">.</span><span class="n">_station_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">queries</span><span class="p">[</span><span class="s2">&quot;network&quot;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">queries</span><span class="p">[</span><span class="s2">&quot;network&quot;</span><span class="p">](</span><span class="n">net_code</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                        <span class="k">continue</span>
                <span class="k">if</span> <span class="n">queries</span><span class="p">[</span><span class="s2">&quot;station&quot;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">queries</span><span class="p">[</span><span class="s2">&quot;station&quot;</span><span class="p">](</span><span class="n">sta_code</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                        <span class="k">continue</span>

            <span class="c1"># Check if the coordinates have to be parsed. Only station level</span>
            <span class="c1"># coordinates are used.</span>
            <span class="k">if</span> <span class="n">queries</span><span class="p">[</span><span class="s2">&quot;latitude&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">queries</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">queries</span><span class="p">[</span><span class="s2">&quot;elevation_in_m&quot;</span><span class="p">]:</span>
                <span class="c1"># This will parse the StationXML files in a very fast manner</span>
                <span class="c1"># (but this is still an I/O heavy process!)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">coords</span> <span class="o">=</span> <span class="n">station</span><span class="o">.</span><span class="n">coordinates</span>
                    <span class="n">latitude</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="s2">&quot;latitude&quot;</span><span class="p">]</span>
                    <span class="n">longitude</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">]</span>
                    <span class="n">elevation_in_m</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="s2">&quot;elevation_in_m&quot;</span><span class="p">]</span>
                <span class="k">except</span> <span class="n">NoStationXMLForStation</span><span class="p">:</span>
                    <span class="n">latitude</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">longitude</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">elevation_in_m</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="k">if</span> <span class="n">queries</span><span class="p">[</span><span class="s2">&quot;latitude&quot;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">queries</span><span class="p">[</span><span class="s2">&quot;latitude&quot;</span><span class="p">](</span><span class="n">latitude</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                        <span class="k">continue</span>

                <span class="k">if</span> <span class="n">queries</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">queries</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">](</span><span class="n">longitude</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                        <span class="k">continue</span>

                <span class="k">if</span> <span class="n">queries</span><span class="p">[</span><span class="s2">&quot;elevation_in_m&quot;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">queries</span><span class="p">[</span><span class="s2">&quot;elevation_in_m&quot;</span><span class="p">](</span><span class="n">elevation_in_m</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                        <span class="k">continue</span>

            <span class="n">wfs</span> <span class="o">=</span> <span class="n">station</span><span class="o">.</span><span class="n">filter_waveforms</span><span class="p">(</span><span class="n">queries</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">wfs</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">yield</span> <span class="n">FilteredWaveformAccessor</span><span class="p">(</span>
                <span class="n">station_name</span><span class="o">=</span><span class="n">station</span><span class="o">.</span><span class="n">_station_name</span><span class="p">,</span>
                <span class="n">asdf_data_set</span><span class="o">=</span><span class="n">station</span><span class="o">.</span><span class="n">_WaveformAccessor__data_set</span><span class="p">(),</span>
                <span class="n">filtered_items</span><span class="o">=</span><span class="n">wfs</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span></div>


<div class="viewcode-block" id="ASDFDataSet.process_two_files_without_parallel_output">
<a class="viewcode-back" href="../../asdf_data_set.html#pyasdf.asdf_data_set.ASDFDataSet.process_two_files_without_parallel_output">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process_two_files_without_parallel_output</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other_ds</span><span class="p">,</span> <span class="n">process_function</span><span class="p">,</span> <span class="n">traceback_limit</span><span class="o">=</span><span class="mi">3</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process data in two data sets.</span>

<span class="sd">        This is mostly useful for comparing data in two data sets in any</span>
<span class="sd">        number of scenarios. It again takes a function and will apply it on</span>
<span class="sd">        each station that is common in both data sets. Please see the</span>
<span class="sd">        :doc:`parallel_processing` document for more details.</span>

<span class="sd">        Can only be run with MPI.</span>

<span class="sd">        :type other_ds: :class:`.ASDFDataSet`</span>
<span class="sd">        :param other_ds: The data set to compare to.</span>
<span class="sd">        :param process_function: The processing function takes two</span>
<span class="sd">            parameters: The station group from this data set and the matching</span>
<span class="sd">            station group from the other data set.</span>
<span class="sd">        :type traceback_limit: int</span>
<span class="sd">        :param traceback_limit: The length of the traceback printed if an</span>
<span class="sd">            error occurs in one of the workers.</span>
<span class="sd">        :return: A dictionary for each station with gathered values. Will</span>
<span class="sd">            only be available on rank 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ASDFException</span><span class="p">(</span><span class="s2">&quot;Currently only works with MPI.&quot;</span><span class="p">)</span>

        <span class="c1"># Collect the work that needs to be done on rank 0.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Simple function splitting a container into equal length chunks.</span>
<span class="sd">                Order is not preserved but this is potentially an advantage</span>
<span class="sd">                depending on the use case.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">container</span><span class="p">[</span><span class="n">_i</span><span class="p">::</span><span class="n">count</span><span class="p">]</span> <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">)]</span>

            <span class="n">this_stations</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">waveforms</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>
            <span class="n">other_stations</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">other_ds</span><span class="o">.</span><span class="n">waveforms</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>

            <span class="c1"># Usable stations are those that are part of both.</span>
            <span class="n">usable_stations</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">this_stations</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">other_stations</span><span class="p">))</span>
            <span class="n">total_job_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">usable_stations</span><span class="p">)</span>
            <span class="n">jobs</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">usable_stations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">jobs</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Scatter jobs.</span>
        <span class="n">jobs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">jobs</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Dictionary collecting results.</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">_i</span><span class="p">,</span> <span class="n">station</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">jobs</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot; -&gt; Processing approximately task </span><span class="si">%i</span><span class="s2"> of </span><span class="si">%i</span><span class="s2"> ...&quot;</span>
                    <span class="o">%</span> <span class="p">((</span><span class="n">_i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">total_job_count</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">process_function</span><span class="p">(</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">waveforms</span><span class="p">,</span> <span class="n">station</span><span class="p">),</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="n">other_ds</span><span class="o">.</span><span class="n">waveforms</span><span class="p">,</span> <span class="n">station</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="c1"># If an exception is raised print a good error message</span>
                <span class="c1"># and traceback to help diagnose the issue.</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Error during the processing of station &#39;</span><span class="si">%s</span><span class="s2">&#39; on rank </span><span class="si">%i</span><span class="s2">:&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">station</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># Extract traceback from the exception.</span>
                <span class="n">exc_info</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>
                <span class="n">stack</span> <span class="o">=</span> <span class="n">traceback</span><span class="o">.</span><span class="n">extract_stack</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="n">traceback_limit</span><span class="p">)</span>
                <span class="n">tb</span> <span class="o">=</span> <span class="n">traceback</span><span class="o">.</span><span class="n">extract_tb</span><span class="p">(</span><span class="n">exc_info</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">full_tb</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">tb</span>
                <span class="n">exc_line</span> <span class="o">=</span> <span class="n">traceback</span><span class="o">.</span><span class="n">format_exception_only</span><span class="p">(</span><span class="o">*</span><span class="n">exc_info</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">tb</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Traceback (At max </span><span class="si">%i</span><span class="s2"> levels - most recent call &quot;</span>
                    <span class="s2">&quot;last):</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">traceback_limit</span>
                <span class="p">)</span>
                <span class="n">tb</span> <span class="o">+=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">traceback</span><span class="o">.</span><span class="n">format_list</span><span class="p">(</span><span class="n">full_tb</span><span class="p">))</span>
                <span class="n">tb</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="c1"># A bit convoluted but compatible with Python 2 and</span>
                <span class="c1"># 3 and hopefully all encoding problems.</span>
                <span class="n">tb</span> <span class="o">+=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="n">_i</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">_i</span><span class="p">,</span> <span class="s2">&quot;decode&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="n">_i</span>
                    <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="n">exc_line</span>
                <span class="p">)</span>

                <span class="c1"># These potentially keep references to the HDF5 file</span>
                <span class="c1"># which in some obscure way and likely due to</span>
                <span class="c1"># interference with internal HDF5 and Python references</span>
                <span class="c1"># prevents it from getting garbage collected. We</span>
                <span class="c1"># explicitly delete them here and MPI can finalize</span>
                <span class="c1"># afterwards.</span>
                <span class="k">del</span> <span class="n">exc_info</span>
                <span class="k">del</span> <span class="n">stack</span>

                <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">tb</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">results</span><span class="p">[</span><span class="n">station</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>

        <span class="c1"># Gather and create a final dictionary of results.</span>
        <span class="n">gathered_results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">gathered_results</span><span class="p">:</span>
                <span class="n">results</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

        <span class="c1"># Likely not necessary as the gather two line above implies a</span>
        <span class="c1"># barrier but better be safe than sorry.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">results</span></div>


<div class="viewcode-block" id="ASDFDataSet.process">
<a class="viewcode-back" href="../../asdf_data_set.html#pyasdf.asdf_data_set.ASDFDataSet.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">process_function</span><span class="p">,</span>
        <span class="n">output_filename</span><span class="p">,</span>
        <span class="n">tag_map</span><span class="p">,</span>
        <span class="n">traceback_limit</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process the contents of an ``ASDF`` file in parallel.</span>

<span class="sd">        Applies a function to the contents of the current data set and</span>
<span class="sd">        writes the output to a new ``ASDF`` file. Can be run with and</span>
<span class="sd">        without MPI. Please see the :doc:`parallel_processing` document for</span>
<span class="sd">        more details.</span>

<span class="sd">        :type process_function: function</span>
<span class="sd">        :param process_function: A function with two argument:</span>
<span class="sd">            An :class:`obspy.core.stream.Stream` object and an</span>
<span class="sd">            :class:`obspy.core.inventory.inventory.Inventory` object. It should</span>
<span class="sd">            return a :class:`obspy.core.stream.Stream` object which will</span>
<span class="sd">            then be written to the new file.</span>
<span class="sd">        :type output_filename: str</span>
<span class="sd">        :param output_filename: The output filename. Must not yet exist.</span>
<span class="sd">        :type tag_map: dict</span>
<span class="sd">        :param tag_map: A dictionary mapping the input tags to output tags.</span>
<span class="sd">        :type traceback_limit: int</span>
<span class="sd">        :param traceback_limit: The length of the traceback printed if an</span>
<span class="sd">            error occurs in one of the workers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if the file exists.</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Output file &#39;</span><span class="si">%s</span><span class="s2">&#39; already exists.&quot;</span> <span class="o">%</span> <span class="n">output_filename</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">output_filename</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Only check file on one core to improve performance.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">file_exists</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">output_filename</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">file_exists</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># Make sure the exception is still raised on every core.</span>
            <span class="n">file_exists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">file_exists</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">file_exists</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">station_tags</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Only rank 0 zero requires all that information.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mpi</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">stations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">waveforms</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>

            <span class="c1"># Get all possible station and waveform path combinations and let</span>
            <span class="c1"># each process read the data it needs.</span>
            <span class="k">for</span> <span class="n">station</span> <span class="ow">in</span> <span class="n">stations</span><span class="p">:</span>
                <span class="c1"># Get the station and all possible tags.</span>
                <span class="n">waveforms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__file</span><span class="p">[</span><span class="s2">&quot;Waveforms&quot;</span><span class="p">][</span><span class="n">station</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

                <span class="n">tags</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">waveform</span> <span class="ow">in</span> <span class="n">waveforms</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">waveform</span> <span class="o">==</span> <span class="s2">&quot;StationXML&quot;</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">tags</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">waveform</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

                <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">tags</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">tag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tag_map</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="k">continue</span>
                    <span class="n">station_tags</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">station</span><span class="p">,</span> <span class="n">tag</span><span class="p">))</span>
            <span class="n">has_station_tags</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">station_tags</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">has_station_tags</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="p">:</span>
            <span class="n">has_station_tags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">has_station_tags</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">has_station_tags</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No data matching the path map found.&quot;</span><span class="p">)</span>

        <span class="c1"># Copy the station and event data only on the master process.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mpi</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="c1"># Deactivate MPI even if active to not run into any barriers.</span>
            <span class="n">output_data_set</span> <span class="o">=</span> <span class="n">ASDFDataSet</span><span class="p">(</span><span class="n">output_filename</span><span class="p">,</span> <span class="n">mpi</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">station_name</span><span class="p">,</span> <span class="n">station_group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_waveform_group</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">tag</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">station_group</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">tag</span> <span class="o">!=</span> <span class="s2">&quot;StationXML&quot;</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">station_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">output_data_set</span><span class="o">.</span><span class="n">_waveform_group</span><span class="p">:</span>
                        <span class="n">group</span> <span class="o">=</span> <span class="n">output_data_set</span><span class="o">.</span><span class="n">_waveform_group</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span>
                            <span class="n">station_name</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">group</span> <span class="o">=</span> <span class="n">output_data_set</span><span class="o">.</span><span class="n">_waveform_group</span><span class="p">[</span><span class="n">station_name</span><span class="p">]</span>
                    <span class="n">group</span><span class="p">[</span><span class="s2">&quot;StationXML&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:]</span>

            <span class="c1"># Copy the events.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">:</span>
                <span class="n">output_data_set</span><span class="o">.</span><span class="n">events</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span>
            <span class="k">del</span> <span class="n">output_data_set</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="p">:</span>
            <span class="n">compression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__compression</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">compression</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">output_data_set</span> <span class="o">=</span> <span class="n">ASDFDataSet</span><span class="p">(</span><span class="n">output_filename</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">)</span>

        <span class="c1"># Check for MPI, if yes, dispatch to MPI worker, if not dispatch to</span>
        <span class="c1"># the multiprocessing handler.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dispatch_processing_mpi</span><span class="p">(</span>
                <span class="n">process_function</span><span class="p">,</span>
                <span class="n">output_data_set</span><span class="p">,</span>
                <span class="n">station_tags</span><span class="p">,</span>
                <span class="n">tag_map</span><span class="p">,</span>
                <span class="n">traceback_limit</span><span class="o">=</span><span class="n">traceback_limit</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dispatch_processing_multiprocessing</span><span class="p">(</span>
                <span class="n">process_function</span><span class="p">,</span>
                <span class="n">output_data_set</span><span class="p">,</span>
                <span class="n">station_tags</span><span class="p">,</span>
                <span class="n">tag_map</span><span class="p">,</span>
                <span class="n">traceback_limit</span><span class="o">=</span><span class="n">traceback_limit</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_dispatch_processing_mpi</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">process_function</span><span class="p">,</span>
        <span class="n">output_data_set</span><span class="p">,</span>
        <span class="n">station_tags</span><span class="p">,</span>
        <span class="n">tag_map</span><span class="p">,</span>
        <span class="n">traceback_limit</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># Make sure all processes enter here.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dispatch_processing_mpi_master_node</span><span class="p">(</span>
                <span class="n">output_data_set</span><span class="p">,</span> <span class="n">station_tags</span><span class="p">,</span> <span class="n">tag_map</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dispatch_processing_mpi_worker_node</span><span class="p">(</span>
                <span class="n">process_function</span><span class="p">,</span>
                <span class="n">output_data_set</span><span class="p">,</span>
                <span class="n">tag_map</span><span class="p">,</span>
                <span class="n">traceback_limit</span><span class="o">=</span><span class="n">traceback_limit</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_dispatch_processing_mpi_master_node</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">output_dataset</span><span class="p">,</span> <span class="n">station_tags</span><span class="p">,</span> <span class="n">tag_map</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The master node. It distributes the jobs and takes care that</span>
<span class="sd">        metadata modifying actions are collective.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">mpi4py</span><span class="w"> </span><span class="kn">import</span> <span class="n">MPI</span>

        <span class="n">worker_nodes</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">workers_requesting_write</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">jobs</span> <span class="o">=</span> <span class="n">JobQueueHelper</span><span class="p">(</span><span class="n">jobs</span><span class="o">=</span><span class="n">station_tags</span><span class="p">,</span> <span class="n">worker_names</span><span class="o">=</span><span class="n">worker_nodes</span><span class="p">)</span>

        <span class="n">__last_print</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Launching processing using MPI on </span><span class="si">%i</span><span class="s2"> processors.&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

        <span class="c1"># Barrier to indicate we are ready for looping. Must be repeated in</span>
        <span class="c1"># each worker node!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

        <span class="c1"># Reactive event loop.</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">jobs</span><span class="o">.</span><span class="n">all_done</span><span class="p">:</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>

            <span class="c1"># Informative output.</span>
            <span class="k">if</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">__last_print</span> <span class="o">&gt;</span> <span class="mf">2.0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">jobs</span><span class="p">)</span>
                <span class="n">__last_print</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">workers_requesting_write</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">workers_requesting_write</span><span class="p">)</span> <span class="ow">and</span> <span class="n">jobs</span><span class="o">.</span><span class="n">all_poison_pills_received</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;MASTER: initializing metadata synchronization.&quot;</span><span class="p">)</span>

                <span class="c1"># Send force write msgs to all workers and block until all</span>
                <span class="c1"># have been sent. Don&#39;t use blocking send cause then one</span>
                <span class="c1"># will have to wait each time anew and not just once for each.</span>
                <span class="c1"># The message will ready each worker for a collective</span>
                <span class="c1"># operation once its current operation is ready.</span>
                <span class="n">requests</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_send_mpi</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="s2">&quot;MASTER_FORCES_WRITE&quot;</span><span class="p">,</span> <span class="n">blocking</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">rank</span> <span class="ow">in</span> <span class="n">worker_nodes</span>
                <span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">MPI</span><span class="o">.</span><span class="n">Request</span><span class="o">.</span><span class="n">waitall</span><span class="p">(</span><span class="n">requests</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_sync_metadata</span><span class="p">(</span><span class="n">output_dataset</span><span class="p">,</span> <span class="n">tag_map</span><span class="o">=</span><span class="n">tag_map</span><span class="p">)</span>

                <span class="c1"># Reset workers requesting a write.</span>
                <span class="n">workers_requesting_write</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;MASTER: done with metadata synchronization.&quot;</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># Retrieve any possible message and &quot;dispatch&quot; appropriately.</span>
            <span class="n">status</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">Status</span><span class="p">()</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span>
                <span class="n">source</span><span class="o">=</span><span class="n">MPI</span><span class="o">.</span><span class="n">ANY_SOURCE</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">MPI</span><span class="o">.</span><span class="n">ANY_TAG</span><span class="p">,</span> <span class="n">status</span><span class="o">=</span><span class="n">status</span>
            <span class="p">)</span>
            <span class="n">tag</span> <span class="o">=</span> <span class="n">MSG_TAGS</span><span class="p">[</span><span class="n">status</span><span class="o">.</span><span class="n">tag</span><span class="p">]</span>
            <span class="n">source</span> <span class="o">=</span> <span class="n">status</span><span class="o">.</span><span class="n">source</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
                <span class="n">pretty_receiver_log</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="n">status</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;WORKER_REQUESTS_ITEM&quot;</span><span class="p">:</span>
                <span class="c1"># Send poison pill if no more work is available. After</span>
                <span class="c1"># that the worker should not request any more jobs.</span>
                <span class="k">if</span> <span class="n">jobs</span><span class="o">.</span><span class="n">queue_empty</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_send_mpi</span><span class="p">(</span><span class="n">POISON_PILL</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="s2">&quot;MASTER_SENDS_ITEM&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># And send a new station path to process it.</span>
                    <span class="n">station_tag</span> <span class="o">=</span> <span class="n">jobs</span><span class="o">.</span><span class="n">get_job_for_worker</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_send_mpi</span><span class="p">(</span><span class="n">station_tag</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="s2">&quot;MASTER_SENDS_ITEM&quot;</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;WORKER_DONE_WITH_ITEM&quot;</span><span class="p">:</span>
                <span class="n">station_tag</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="n">msg</span>
                <span class="n">jobs</span><span class="o">.</span><span class="n">received_job_from_worker</span><span class="p">(</span><span class="n">station_tag</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;WORKER_REQUESTS_WRITE&quot;</span><span class="p">:</span>
                <span class="n">workers_requesting_write</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;POISON_PILL_RECEIVED&quot;</span><span class="p">:</span>
                <span class="n">jobs</span><span class="o">.</span><span class="n">poison_pill_received</span><span class="p">()</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Master done, shutting down workers...&quot;</span><span class="p">)</span>
        <span class="c1"># Shutdown workers.</span>
        <span class="k">for</span> <span class="n">rank</span> <span class="ow">in</span> <span class="n">worker_nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_send_mpi</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="s2">&quot;ALL_DONE&quot;</span><span class="p">)</span>

        <span class="c1"># Collect any stray messages that a poison pill has been received.</span>
        <span class="c1"># Does not matter for the flow but for aestetic reasons this is nicer.</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="mi">3</span><span class="p">):</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Iprobe</span><span class="p">(</span>
                <span class="n">source</span><span class="o">=</span><span class="n">MPI</span><span class="o">.</span><span class="n">ANY_SOURCE</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">MSG_TAGS</span><span class="p">[</span><span class="s2">&quot;POISON_PILL_RECEIVED&quot;</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="k">continue</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span>
                <span class="n">source</span><span class="o">=</span><span class="n">MPI</span><span class="o">.</span><span class="n">ANY_SOURCE</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">MSG_TAGS</span><span class="p">[</span><span class="s2">&quot;POISON_PILL_RECEIVED&quot;</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">jobs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_dispatch_processing_mpi_worker_node</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">process_function</span><span class="p">,</span> <span class="n">output_dataset</span><span class="p">,</span> <span class="n">tag_map</span><span class="p">,</span> <span class="n">traceback_limit</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A worker node. It gets jobs, processes them and periodically waits</span>
<span class="sd">        until a collective metadata update operation has happened.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stream_buffer</span> <span class="o">=</span> <span class="n">StreamBuffer</span><span class="p">()</span>

        <span class="n">worker_state</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;poison_pill_received&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="s2">&quot;waiting_for_write&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="s2">&quot;waiting_for_item&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="c1"># Barrier to indicate we are ready for looping. Must be repeated in</span>
        <span class="c1"># the master node!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

        <span class="c1"># Loop until the &#39;ALL_DONE&#39; message has been sent.</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_msg</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;ALL_DONE&quot;</span><span class="p">):</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>

            <span class="c1"># Check if master requested a write.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_msg</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;MASTER_FORCES_WRITE&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sync_metadata</span><span class="p">(</span><span class="n">output_dataset</span><span class="p">,</span> <span class="n">tag_map</span><span class="o">=</span><span class="n">tag_map</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream_buffer</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">trace</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                            <span class="n">output_dataset</span><span class="o">.</span><span class="n">_add_trace_write_independent_information</span><span class="p">(</span>  <span class="c1"># NOQA</span>
                                <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">__info</span><span class="p">,</span> <span class="n">trace</span>
                            <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_send_mpi</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)),</span>
                        <span class="mi">0</span><span class="p">,</span>
                        <span class="s2">&quot;WORKER_DONE_WITH_ITEM&quot;</span><span class="p">,</span>
                        <span class="n">blocking</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stream_buffer</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                <span class="n">worker_state</span><span class="p">[</span><span class="s2">&quot;waiting_for_write&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># Keep looping and wait for either the next write or that the</span>
            <span class="c1"># loop terminates.</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">worker_state</span><span class="p">[</span><span class="s2">&quot;waiting_for_write&quot;</span><span class="p">]</span>
                <span class="ow">or</span> <span class="n">worker_state</span><span class="p">[</span><span class="s2">&quot;poison_pill_received&quot;</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">worker_state</span><span class="p">[</span><span class="s2">&quot;waiting_for_item&quot;</span><span class="p">]:</span>
                <span class="c1"># Send message that the worker requires work.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_send_mpi</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;WORKER_REQUESTS_ITEM&quot;</span><span class="p">,</span> <span class="n">blocking</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">worker_state</span><span class="p">[</span><span class="s2">&quot;waiting_for_item&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">continue</span>

            <span class="n">msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_msg</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;MASTER_SENDS_ITEM&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">msg</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Beyond this point it will always have received a new item.</span>
            <span class="n">station_tag</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">data</span>
            <span class="n">worker_state</span><span class="p">[</span><span class="s2">&quot;waiting_for_item&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># If no more work to be done, store state and keep looping as</span>
            <span class="c1"># stuff still might require to be written.</span>
            <span class="k">if</span> <span class="n">station_tag</span> <span class="o">==</span> <span class="n">POISON_PILL</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream_buffer</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_send_mpi</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;WORKER_REQUESTS_WRITE&quot;</span><span class="p">,</span> <span class="n">blocking</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">worker_state</span><span class="p">[</span><span class="s2">&quot;waiting_for_write&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">worker_state</span><span class="p">[</span><span class="s2">&quot;poison_pill_received&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_send_mpi</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;POISON_PILL_RECEIVED&quot;</span><span class="p">,</span> <span class="n">blocking</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># Otherwise process the data.</span>
            <span class="n">stream</span><span class="p">,</span> <span class="n">inv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data_for_tag</span><span class="p">(</span><span class="o">*</span><span class="n">station_tag</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">stream</span> <span class="o">=</span> <span class="n">process_function</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">inv</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="c1"># If an exception is raised print a good error message</span>
                <span class="c1"># and traceback to help diagnose the issue.</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Error during the processing of station &#39;</span><span class="si">%s</span><span class="s2">&#39; &quot;</span>
                    <span class="s2">&quot;and tag &#39;</span><span class="si">%s</span><span class="s2">&#39; on rank </span><span class="si">%i</span><span class="s2">:&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">station_tag</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">station_tag</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">rank</span><span class="p">)</span>
                <span class="p">)</span>

                <span class="c1"># Extract traceback from the exception.</span>
                <span class="n">exc_info</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>
                <span class="n">stack</span> <span class="o">=</span> <span class="n">traceback</span><span class="o">.</span><span class="n">extract_stack</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="n">traceback_limit</span><span class="p">)</span>
                <span class="n">tb</span> <span class="o">=</span> <span class="n">traceback</span><span class="o">.</span><span class="n">extract_tb</span><span class="p">(</span><span class="n">exc_info</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">full_tb</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">tb</span>
                <span class="n">exc_line</span> <span class="o">=</span> <span class="n">traceback</span><span class="o">.</span><span class="n">format_exception_only</span><span class="p">(</span><span class="o">*</span><span class="n">exc_info</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">tb</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Traceback (At max </span><span class="si">%i</span><span class="s2"> levels - most recent call &quot;</span>
                    <span class="s2">&quot;last):</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">traceback_limit</span>
                <span class="p">)</span>
                <span class="n">tb</span> <span class="o">+=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">traceback</span><span class="o">.</span><span class="n">format_list</span><span class="p">(</span><span class="n">full_tb</span><span class="p">))</span>
                <span class="n">tb</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="c1"># A bit convoluted but compatible with Python 2 and</span>
                <span class="c1"># 3 and hopefully all encoding problems.</span>
                <span class="n">tb</span> <span class="o">+=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="n">_i</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">_i</span><span class="p">,</span> <span class="s2">&quot;decode&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="n">_i</span>
                    <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="n">exc_line</span>
                <span class="p">)</span>

                <span class="c1"># These potentially keep references to the HDF5 file</span>
                <span class="c1"># which in some obscure way and likely due to</span>
                <span class="c1"># interference with internal HDF5 and Python references</span>
                <span class="c1"># prevents it from getting garbage collected. We</span>
                <span class="c1"># explicitly delete them here and MPI can finalize</span>
                <span class="c1"># afterwards.</span>
                <span class="k">del</span> <span class="n">exc_info</span>
                <span class="k">del</span> <span class="n">stack</span>

                <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">tb</span><span class="p">)</span>

                <span class="c1"># Make sure synchronization works.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stream_buffer</span><span class="p">[</span><span class="n">station_tag</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Add stream to buffer only if no error occured.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stream_buffer</span><span class="p">[</span><span class="n">station_tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">stream</span>

            <span class="c1"># If the buffer is too large, request from the master to stop</span>
            <span class="c1"># the current execution.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream_buffer</span><span class="o">.</span><span class="n">get_size</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">MAX_MEMORY_PER_WORKER_IN_MB</span> <span class="o">*</span> <span class="mi">1024</span><span class="o">**</span><span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_send_mpi</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;WORKER_REQUESTS_WRITE&quot;</span><span class="p">,</span> <span class="n">blocking</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">worker_state</span><span class="p">[</span><span class="s2">&quot;waiting_for_write&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Worker </span><span class="si">%i</span><span class="s2"> shutting down...&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">rank</span><span class="p">)</span>

        <span class="c1"># Collect any left-over messages. This can happen if the node</span>
        <span class="c1"># requests a new item (which would be a poison pill in any case) but</span>
        <span class="c1"># the master in the meanwhile forces a write which might cause</span>
        <span class="c1"># everything to be finished so the message is never collected. This</span>
        <span class="c1"># is troublesome if more than one ASDF file is processed in sequence</span>
        <span class="c1"># as the message would then spill over to the next file.</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_msg</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;MASTER_SENDS_ITEM&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_sync_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_dataset</span><span class="p">,</span> <span class="n">tag_map</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method responsible for synchronizing metadata across all processes</span>
<span class="sd">        in the HDF5 file. All metadata changing operations must be collective.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;stream_buffer&quot;</span><span class="p">):</span>
            <span class="n">sendobj</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">stream</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream_buffer</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">stream</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">trace</span> <span class="ow">in</span> <span class="n">stream</span><span class="p">:</span>
                    <span class="n">info</span> <span class="o">=</span> <span class="n">output_dataset</span><span class="o">.</span><span class="n">_add_trace_get_collective_information</span><span class="p">(</span>  <span class="c1"># NOQA</span>
                        <span class="n">trace</span><span class="p">,</span> <span class="n">tag_map</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="p">)</span>
                    <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">__info</span> <span class="o">=</span> <span class="n">info</span>
                    <span class="n">sendobj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sendobj</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allgather</span><span class="p">(</span><span class="n">sendobj</span><span class="o">=</span><span class="n">sendobj</span><span class="p">)</span>
        <span class="c1"># Chain and remove None.</span>
        <span class="n">trace_info</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># Write collective part.</span>
        <span class="k">for</span> <span class="n">info</span> <span class="ow">in</span> <span class="n">trace_info</span><span class="p">:</span>
            <span class="n">output_dataset</span><span class="o">.</span><span class="n">_add_trace_write_collective_information</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>

        <span class="c1"># Make sure all remaining write requests are processed before</span>
        <span class="c1"># proceeding.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">rank</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_msg</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span> <span class="s2">&quot;WORKER_REQUESTS_WRITE&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="ow">and</span> <span class="n">msg</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;MASTER: Ignoring write request by worker </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">rank</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_dispatch_processing_multiprocessing</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">process_function</span><span class="p">,</span>
        <span class="n">output_data_set</span><span class="p">,</span>
        <span class="n">station_tags</span><span class="p">,</span>
        <span class="n">tag_map</span><span class="p">,</span>
        <span class="n">traceback_limit</span><span class="p">,</span>
        <span class="n">cpu_count</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;win32&quot;</span><span class="p">:</span>
            <span class="n">ctx</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">get_context</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Needed for python 3.8 on unix for some reason.</span>
            <span class="n">ctx</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">get_context</span><span class="p">(</span><span class="s2">&quot;forkserver&quot;</span><span class="p">)</span>

        <span class="n">input_filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span>
        <span class="n">output_filename</span> <span class="o">=</span> <span class="n">output_data_set</span><span class="o">.</span><span class="n">filename</span>

        <span class="c1"># Make sure all HDF5 file handles are closed before fork() is called.</span>
        <span class="c1"># Might become irrelevant if the HDF5 library sees some changes but</span>
        <span class="c1"># right now it is necessary.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close</span><span class="p">()</span>
        <span class="n">output_data_set</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="n">output_data_set</span><span class="o">.</span><span class="n">_close</span><span class="p">()</span>
        <span class="k">del</span> <span class="n">output_data_set</span>

        <span class="c1"># Lock for input and output files. Probably not needed for the input</span>
        <span class="c1"># files but better be safe.</span>
        <span class="n">input_file_lock</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
        <span class="n">output_file_lock</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>

        <span class="c1"># Also lock the printing on screen to not mangle the output.</span>
        <span class="n">print_lock</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>

        <span class="c1"># Use either the given number of cores or the maximum number of cores.</span>
        <span class="k">if</span> <span class="n">cpu_count</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">cpu_count</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>

        <span class="c1"># Don&#39;t use more cores than jobs.</span>
        <span class="n">cpu_count</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">cpu_count</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">station_tags</span><span class="p">))</span>

        <span class="c1"># Create the input queue containing the jobs.</span>
        <span class="n">input_queue</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">JoinableQueue</span><span class="p">(</span>
            <span class="n">maxsize</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mf">1.1</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">station_tags</span><span class="p">)</span> <span class="o">+</span> <span class="n">cpu_count</span><span class="p">)))</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="n">station_tags</span><span class="p">:</span>
            <span class="n">input_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">_i</span><span class="p">)</span>

        <span class="c1"># Put some poison pills.</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cpu_count</span><span class="p">):</span>
            <span class="n">input_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">POISON_PILL</span><span class="p">)</span>

        <span class="c1"># Give a short time for the queues to play catch-up.</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>

        <span class="c1"># The output queue will collect the reports from the jobs.</span>
        <span class="n">output_queue</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>

        <span class="c1"># Create n processes, with n being the number of available CPUs.</span>
        <span class="n">processes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cpu_count</span><span class="p">):</span>
            <span class="n">processes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">_Process</span><span class="p">(</span>
                    <span class="n">in_queue</span><span class="o">=</span><span class="n">input_queue</span><span class="p">,</span>
                    <span class="n">out_queue</span><span class="o">=</span><span class="n">output_queue</span><span class="p">,</span>
                    <span class="n">in_filename</span><span class="o">=</span><span class="n">input_filename</span><span class="p">,</span>
                    <span class="n">out_filename</span><span class="o">=</span><span class="n">output_filename</span><span class="p">,</span>
                    <span class="n">in_lock</span><span class="o">=</span><span class="n">input_file_lock</span><span class="p">,</span>
                    <span class="n">out_lock</span><span class="o">=</span><span class="n">output_file_lock</span><span class="p">,</span>
                    <span class="n">print_lock</span><span class="o">=</span><span class="n">print_lock</span><span class="p">,</span>
                    <span class="n">processing_function</span><span class="o">=</span><span class="n">dill</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">process_function</span><span class="p">),</span>
                    <span class="n">process_name</span><span class="o">=</span><span class="n">i</span><span class="p">,</span>
                    <span class="n">total_task_count</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">station_tags</span><span class="p">),</span>
                    <span class="n">cpu_count</span><span class="o">=</span><span class="n">cpu_count</span><span class="p">,</span>
                    <span class="n">traceback_limit</span><span class="o">=</span><span class="n">traceback_limit</span><span class="p">,</span>
                    <span class="n">tag_map</span><span class="o">=</span><span class="n">tag_map</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Launching processing using multiprocessing on </span><span class="si">%i</span><span class="s2"> cores ...&quot;</span> <span class="o">%</span> <span class="n">cpu_count</span><span class="p">)</span>
        <span class="n">_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">process</span> <span class="ow">in</span> <span class="n">processes</span><span class="p">:</span>
            <span class="n">process</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">process</span> <span class="ow">in</span> <span class="n">processes</span><span class="p">:</span>
            <span class="n">process</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

        <span class="n">_end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">_dur</span> <span class="o">=</span> <span class="n">_end</span> <span class="o">-</span> <span class="n">_start</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;Finished processing in </span><span class="si">%.2f</span><span class="s2"> seconds (</span><span class="si">%.2g</span><span class="s2"> sec/station).&quot;</span>
            <span class="o">%</span> <span class="p">(</span><span class="n">_dur</span><span class="p">,</span> <span class="n">_dur</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">station_tags</span><span class="p">))</span>
        <span class="p">)</span>

        <span class="n">ASDFDataSet</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__original_filename</span><span class="p">)</span>

        <span class="k">return</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_msg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">tag</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method to get a message if available, returns a</span>
<span class="sd">        ReceivedMessage instance in case a message is available, None</span>
<span class="sd">        otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tag</span> <span class="o">=</span> <span class="n">MSG_TAGS</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Iprobe</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">tag</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">ReceivedMessage</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">tag</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="n">pretty_receiver_log</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">msg</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_send_mpi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">blocking</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method to send a message via MPI.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tag</span> <span class="o">=</span> <span class="n">MSG_TAGS</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">blocking</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">obj</span><span class="o">=</span><span class="n">obj</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="n">dest</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">tag</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">isend</span><span class="p">(</span><span class="n">obj</span><span class="o">=</span><span class="n">obj</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="n">dest</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">tag</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="n">pretty_sender_log</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_recv_mpi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">tag</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method to receive a message via MPI.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tag</span> <span class="o">=</span> <span class="n">MSG_TAGS</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">tag</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="n">pretty_receiver_log</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">msg</span>

<div class="viewcode-block" id="ASDFDataSet.get_all_coordinates">
<a class="viewcode-back" href="../../asdf_data_set.html#pyasdf.asdf_data_set.ASDFDataSet.get_all_coordinates">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_all_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a dictionary of the coordinates of all stations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">station</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">waveforms</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">coords</span><span class="p">[</span><span class="n">station</span><span class="o">.</span><span class="n">_station_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">station</span><span class="o">.</span><span class="n">coordinates</span>
            <span class="k">except</span> <span class="n">NoStationXMLForStation</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="n">coords</span></div>


<div class="viewcode-block" id="ASDFDataSet.get_waveforms">
<a class="viewcode-back" href="../../asdf_data_set.html#pyasdf.asdf_data_set.ASDFDataSet.get_waveforms">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_waveforms</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">network</span><span class="p">,</span>
        <span class="n">station</span><span class="p">,</span>
        <span class="n">location</span><span class="p">,</span>
        <span class="n">channel</span><span class="p">,</span>
        <span class="n">starttime</span><span class="p">,</span>
        <span class="n">endtime</span><span class="p">,</span>
        <span class="n">tag</span><span class="p">,</span>
        <span class="n">automerge</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Directly access waveforms.</span>

<span class="sd">        This enables a more exact specification of what one wants to</span>
<span class="sd">        retrieve from an ASDF file. Most importantly it honors the start and</span>
<span class="sd">        end time and only reads those samples that are actually desired -</span>
<span class="sd">        this is especially important for large, continuous data sets.</span>

<span class="sd">        :type network: str</span>
<span class="sd">        :param network: The network code. Can contain wildcards.</span>
<span class="sd">        :type station: str</span>
<span class="sd">        :param station: The station code. Can contain wildcards.</span>
<span class="sd">        :type location: str</span>
<span class="sd">        :param location: The location code. Can contain wildcards.</span>
<span class="sd">        :type channel: str</span>
<span class="sd">        :param channel: The channel code. Can contain wildcards.</span>
<span class="sd">        :type starttime: :class:`obspy.core.utcdatetime.UTCDateTime`.</span>
<span class="sd">        :param starttime: The time of the first sample.</span>
<span class="sd">        :type endtime: :class:`obspy.core.utcdatetime.UTCDateTime`.</span>
<span class="sd">        :param endtime: The time of the last sample.</span>
<span class="sd">        :type tag: str</span>
<span class="sd">        :param tag: The tag to extract.</span>
<span class="sd">        :type automerge: bool</span>
<span class="sd">        :param automerge: Automatically merge adjacent traces if they are</span>
<span class="sd">            exactly adjacent (e.g. last sample from previous trace + first</span>
<span class="sd">            sample of next trace are one delta apart).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">Stream</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ifilter</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">network</span> <span class="o">==</span> <span class="n">network</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">station</span> <span class="o">==</span> <span class="n">station</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">location</span> <span class="o">==</span> <span class="n">location</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">channel</span> <span class="o">==</span> <span class="n">channel</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="n">tag</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">starttime</span> <span class="o">&lt;=</span> <span class="n">endtime</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">endtime</span> <span class="o">&gt;=</span> <span class="n">starttime</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">i</span><span class="o">.</span><span class="n">get_waveform_tags</span><span class="p">():</span>
                <span class="n">st</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">get_item</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">starttime</span><span class="o">=</span><span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span><span class="o">=</span><span class="n">endtime</span><span class="p">))</span>

        <span class="c1"># Cleanup merge - will only merge exactly adjacent traces.</span>
        <span class="k">if</span> <span class="n">automerge</span><span class="p">:</span>
            <span class="n">st</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">method</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">st</span></div>
</div>



<span class="k">class</span><span class="w"> </span><span class="nc">_Process</span><span class="p">(</span><span class="n">multiprocessing</span><span class="o">.</span><span class="n">Process</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal process used for the processing data in parallel with the</span>
<span class="sd">    multi-processing module.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">in_queue</span><span class="p">,</span>
        <span class="n">out_queue</span><span class="p">,</span>
        <span class="n">in_filename</span><span class="p">,</span>
        <span class="n">out_filename</span><span class="p">,</span>
        <span class="n">in_lock</span><span class="p">,</span>
        <span class="n">out_lock</span><span class="p">,</span>
        <span class="n">print_lock</span><span class="p">,</span>
        <span class="n">processing_function</span><span class="p">,</span>
        <span class="n">process_name</span><span class="p">,</span>
        <span class="n">total_task_count</span><span class="p">,</span>
        <span class="n">cpu_count</span><span class="p">,</span>
        <span class="n">traceback_limit</span><span class="p">,</span>
        <span class="n">tag_map</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_queue</span> <span class="o">=</span> <span class="n">in_queue</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_queue</span> <span class="o">=</span> <span class="n">out_queue</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_filename</span> <span class="o">=</span> <span class="n">in_filename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_filename</span> <span class="o">=</span> <span class="n">out_filename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_file_lock</span> <span class="o">=</span> <span class="n">in_lock</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_file_lock</span> <span class="o">=</span> <span class="n">out_lock</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print_lock</span> <span class="o">=</span> <span class="n">print_lock</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processing_function</span> <span class="o">=</span> <span class="n">processing_function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__process_name</span> <span class="o">=</span> <span class="n">process_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__task_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__total_task_count</span> <span class="o">=</span> <span class="n">total_task_count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__cpu_count</span> <span class="o">=</span> <span class="n">cpu_count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__traceback_limit</span> <span class="o">=</span> <span class="n">traceback_limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__tag_map</span> <span class="o">=</span> <span class="n">tag_map</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__task_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">stationtag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_queue</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">stationtag</span> <span class="o">==</span> <span class="n">POISON_PILL</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">input_queue</span><span class="o">.</span><span class="n">task_done</span><span class="p">()</span>
                <span class="k">break</span>

            <span class="c1"># Only print on &quot;rank&quot; 0.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__process_name</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_lock</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="s2">&quot; -&gt; Processing approximately task </span><span class="si">%i</span><span class="s2"> of &quot;</span>
                        <span class="s2">&quot;</span><span class="si">%i</span><span class="s2"> ...&quot;</span>
                        <span class="o">%</span> <span class="p">(</span>
                            <span class="nb">min</span><span class="p">(</span>
                                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__task_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cpu_count</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">__total_task_count</span><span class="p">,</span>
                            <span class="p">),</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">__total_task_count</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

            <span class="n">station</span><span class="p">,</span> <span class="n">tag</span> <span class="o">=</span> <span class="n">stationtag</span>

            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__process_name</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_file_lock</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;TRYING TO OPEN FILE.&quot;</span><span class="p">)</span>
                <span class="n">input_data_set</span> <span class="o">=</span> <span class="n">ASDFDataSet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;OPENED FILE&quot;</span><span class="p">)</span>
                <span class="n">stream</span><span class="p">,</span> <span class="n">inv</span> <span class="o">=</span> <span class="n">input_data_set</span><span class="o">.</span><span class="n">get_data_for_tag</span><span class="p">(</span><span class="n">station</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span>
                <span class="n">input_data_set</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
                <span class="k">del</span> <span class="n">input_data_set</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;DELETE FILE&quot;</span><span class="p">)</span>

            <span class="c1"># Using dill as it works on more systems.</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">dill</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processing_function</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">output_stream</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">inv</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Error during the processing of station &#39;</span><span class="si">%s</span><span class="s2">&#39; &quot;</span>
                    <span class="s2">&quot;and tag &#39;</span><span class="si">%s</span><span class="s2">&#39; on CPU </span><span class="si">%i</span><span class="s2">:&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">stationtag</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">stationtag</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">__process_name</span><span class="p">)</span>
                <span class="p">)</span>

                <span class="c1"># Extract traceback from the exception.</span>
                <span class="n">exc_info</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>
                <span class="n">stack</span> <span class="o">=</span> <span class="n">traceback</span><span class="o">.</span><span class="n">extract_stack</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__traceback_limit</span><span class="p">)</span>
                <span class="n">tb</span> <span class="o">=</span> <span class="n">traceback</span><span class="o">.</span><span class="n">extract_tb</span><span class="p">(</span><span class="n">exc_info</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">full_tb</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">tb</span>
                <span class="n">exc_line</span> <span class="o">=</span> <span class="n">traceback</span><span class="o">.</span><span class="n">format_exception_only</span><span class="p">(</span><span class="o">*</span><span class="n">exc_info</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">tb</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Traceback (At max </span><span class="si">%i</span><span class="s2"> levels - most recent call &quot;</span>
                    <span class="s2">&quot;last):</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__traceback_limit</span>
                <span class="p">)</span>
                <span class="n">tb</span> <span class="o">+=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">traceback</span><span class="o">.</span><span class="n">format_list</span><span class="p">(</span><span class="n">full_tb</span><span class="p">))</span>
                <span class="n">tb</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="c1"># A bit convoluted but compatible with Python 2 and</span>
                <span class="c1"># 3 and hopefully all encoding problems.</span>
                <span class="n">tb</span> <span class="o">+=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="n">_i</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">_i</span><span class="p">,</span> <span class="s2">&quot;decode&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="n">_i</span>
                    <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="n">exc_line</span>
                <span class="p">)</span>

                <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_lock</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">tb</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">input_queue</span><span class="o">.</span><span class="n">task_done</span><span class="p">()</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">output_stream</span><span class="p">:</span>
                <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_file_lock</span><span class="p">:</span>
                    <span class="n">output_data_set</span> <span class="o">=</span> <span class="n">ASDFDataSet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_filename</span><span class="p">)</span>
                    <span class="n">output_data_set</span><span class="o">.</span><span class="n">add_waveforms</span><span class="p">(</span>
                        <span class="n">output_stream</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__tag_map</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="k">del</span> <span class="n">output_data_set</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">input_queue</span><span class="o">.</span><span class="n">task_done</span><span class="p">()</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2014-2023, Lion Krischer.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>